package obsproxygen

import (
	"context"
	"fmt"
	"io"
	"strings"

	"github.com/dave/jennifer/jen"
	"github.com/xaionaro-go/obs-grpc-proxy/pkg/obsdoc"
)

func Generate(
	ctx context.Context,
	w io.Writer,
	p *obsdoc.Protocol,
) error {
	if p == nil {
		return nil
	}

	code := jen.NewFile("obsgrpcproxy")
	code.HeaderComment("This file was automatically generated by github.com/xaionaro-go/obs-grpc-proxy/scripts/generate")

	for idx, request := range p.Requests {
		err := generateRequest(code, request)
		if err != nil {
			return fmt.Errorf("unable to generate code for request #%d:%s: %w", idx, request.RequestType, err)
		}
	}

	err := code.Render(w)
	if err != nil {
		return fmt.Errorf("unable to render the code: %w", err)
	}

	return nil
}

func generateRequest(
	code *jen.File,
	request obsdoc.Request,
) error {
	var requestFieldAssigns []jen.Code
	for _, field := range request.RequestFields {
		assignField := jen.Id(title(field.ValueName)).Op(":")
		src := jen.Id("req").Dot(title(field.ValueName))
		castToType := ""
		convertFunc := ""
		switch field.ValueType {
		case "String":
			castToType = "string"
			convertFunc = "ptr"
		case "Number":
			if field.ValueOptional {
				convertFunc = "ptrInt64toFloat64"
			} else {
				castToType = "int64"
				convertFunc = "ptr"
			}
		case "Boolean":
			convertFunc = "ptr"
		}
		if castToType != "" {
			src = jen.Params(jen.Id(castToType)).Params(src)
		}
		if convertFunc != "" {
			src = jen.Id(convertFunc).Call(src)
		}
		assignField = assignField.Add(src).Op(",")
		requestFieldAssigns = append(
			requestFieldAssigns,
			assignField,
		)
	}

	var responseFieldAssigns []jen.Code
	for _, field := range request.ResponseFields {
		assignField := jen.Id(title(field.ValueName)).Op(":")
		src := jen.Id("resp").Dot(title(field.ValueName))
		switch field.ValueType {
		case "Any":
			src = jen.Id("anyGo2Protobuf").Call(src)
		case "String":
			src = jen.Params(jen.Id("[]byte")).Call(src)
		case "Number":
			src = jen.Params(jen.Id("int64")).Call(src)
		case "Array<String>":
			src = jen.Id("stringSliceGo2Protobuf").Call(src)
		}
		assignField = assignField.Add(src).Op(",")
		responseFieldAssigns = append(
			responseFieldAssigns,
			assignField,
		)
	}

	respID := "resp"
	respOp := ":="
	if len(responseFieldAssigns) == 0 {
		respID = "_"
		respOp = "="
	}

	code.Func().Params(jen.Id("p").Op("*").Id("Proxy")).Id(request.RequestType).Params(
		jen.Id("ctx").Qual("context", "Context"),
		jen.Id("req").Op("*").Qual("github.com/xaionaro-go/obs-grpc-proxy/protobuf/go/obs_grpc", request.RequestType+"Request"),
	).Params(
		jen.Op("*").Qual("github.com/xaionaro-go/obs-grpc-proxy/protobuf/go/obs_grpc", request.RequestType+"Response"),
		jen.Error(),
	).Block(
		jen.List(jen.Id("client"), jen.Id("onFinish"), jen.Id("err")).Op(":=").Id("p").Dot("GetClient").Call(),
		jen.If(jen.Id("onFinish").Op("!=").Nil()).Block(
			jen.Defer().Id("onFinish").Call(),
		),
		jen.If(jen.Id("err").Op("!=").Nil()).Block(jen.Return(jen.List(jen.Nil(), jen.Qual("fmt", "Errorf").Params(jen.Lit("unable to get a client: %w"), jen.Id("err"))))),
		jen.Id("params").Op(":=").Op("&").Qual("github.com/andreykaipov/goobs/api/requests/"+categoryObs2GoPkgName(request.Category), request.RequestType+"Params").Block(
			requestFieldAssigns...,
		),
		jen.List(jen.Id(respID), jen.Id("err")).Op(respOp).Id("client").Dot(categoryObs2Go(request.Category)).Dot(request.RequestType).Call(
			jen.Id("params"),
		),
		jen.If(jen.Id("err").Op("!=").Nil()).Block(jen.Return(jen.List(jen.Nil(), jen.Id("err")))),
		jen.Id("result").Op(":=").Op("&").Qual("github.com/xaionaro-go/obs-grpc-proxy/protobuf/go/obs_grpc", request.RequestType+"Response").Block(responseFieldAssigns...),
		jen.Return(jen.List(jen.Id("result"), jen.Nil())),
	)
	return nil
}

func title(s string) string {
	if len(s) == 0 {
		return ""
	}

	return strings.ToUpper(s[:1]) + s[1:]
}

func categoryObs2Go(obsCat string) string {
	words := strings.Split(obsCat, " ")
	for idx := range words {
		words[idx] = title(words[idx])
	}
	return strings.Join(words, "")
}

func categoryObs2GoPkgName(obsCat string) string {
	words := strings.Split(obsCat, " ")
	for idx := range words {
		words[idx] = strings.ToLower(words[idx])
	}
	return strings.Join(words, "")
}
