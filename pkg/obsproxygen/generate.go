package obsproxygen

import (
	"context"
	"fmt"
	"io"
	"strings"

	"github.com/dave/jennifer/jen"
	"github.com/xaionaro-go/obs-grpc-proxy/pkg/obsdoc"
	"github.com/xaionaro-go/obs-grpc-proxy/pkg/obsprotobufgen"
	"github.com/yoheimuta/go-protoparser/v4/parser"
)

func Generate(
	ctx context.Context,
	w io.Writer,
	p *obsdoc.Protocol,
	staticProto *parser.Proto,
) error {
	if p == nil {
		return nil
	}

	existingObjectTypes := map[string]struct{}{}
	if staticProto != nil {
		for _, v := range staticProto.ProtoBody {
			msg, ok := v.(*parser.Message)
			if !ok {
				continue
			}
			existingObjectTypes[msg.MessageName] = struct{}{}
		}
	}

	code := jen.NewFile("obsgrpcproxy")
	code.HeaderComment("This file was automatically generated by github.com/xaionaro-go/obs-grpc-proxy/scripts/generate")
	code.Var().Id("_").Op("=").Params(jen.Id("*").Qual("github.com/andreykaipov/goobs/api/typedefs", "Input")).Call(jen.Nil())

	for idx, request := range p.Requests {
		err := generateRequest(code, request, existingObjectTypes)
		if err != nil {
			return fmt.Errorf("unable to generate code for request #%d:%s: %w", idx, request.RequestType, err)
		}
	}

	err := code.Render(w)
	if err != nil {
		return fmt.Errorf("unable to render the code: %w", err)
	}

	return nil
}

func goOBSIsInt(fieldName string) bool {
	switch {
	case strings.HasSuffix(fieldName, "Index"):
		return true
	case strings.HasSuffix(fieldName, "Id"):
		return true
	}
	return false
}

func goOBSIsFloatNumber(fieldName string) bool {
	switch {
	case strings.HasSuffix(fieldName, "Offset"):
		return true
	case strings.HasSuffix(fieldName, "Cursor"):
		return true
	case strings.HasSuffix(fieldName, "Duration"):
		return true
	case strings.HasSuffix(fieldName, "Position"):
		return true
	case strings.HasSuffix(fieldName, "Millis"):
		return true
	case strings.HasSuffix(fieldName, "Frames"):
		return true
	case strings.HasSuffix(fieldName, "Numerator"):
		return true
	case strings.HasSuffix(fieldName, "Denominator"):
		return true
	case strings.HasSuffix(fieldName, "Width"):
		return true
	case strings.HasSuffix(fieldName, "Height"):
		return true
	case strings.HasSuffix(fieldName, "Mul"):
		return true
	case strings.HasSuffix(fieldName, "Db"):
		return true
	case strings.HasSuffix(fieldName, "Quality"):
		return true
	}
	return false
}

func generateRequest(
	code *jen.File,
	request obsdoc.Request,
	existingObjectTypes map[string]struct{},
) error {
	var requestFieldAssigns []jen.Code
	for _, field := range request.RequestFields {
		if strings.Contains(field.ValueName, ".") {
			continue
		}
		assignField := jen.Id(title(field.ValueName)).Op(":")
		src := jen.Id("req").Dot(obsprotobufgen.FieldNameObs2Protobuf(title(field.ValueName)))
		castToType := ""
		convertFunc := ""
		switch field.ValueType {
		case "String":
			baseTypeFrom := obsprotobufgen.TypeNameObs2Protobuf(field.ValueType, field.ValueName, existingObjectTypes)
			if baseTypeFrom == "bytes" {
				castToType = "string"
				convertFunc = "ptr"
			}
			if !field.ValueOptional {
				convertFunc = "ptr"
			}
		case "Number":
			fieldName := title(field.ValueName)
			if obsprotobufgen.IsFloatNumber(fieldName) {
				if !field.ValueOptional {
					convertFunc = "ptr"
				}
			} else {
				baseTypeTo := "int64"
				baseTypeFrom := "int64"
				switch {
				case goOBSIsInt(fieldName):
					baseTypeTo = "int"
				case goOBSIsFloatNumber(fieldName):
					baseTypeTo = "float64"
				}
				if baseTypeFrom == baseTypeTo {
					if !field.ValueOptional {
						convertFunc = "ptr"
					}
				} else {
					if field.ValueOptional {
						convertFunc = "ptr" + title(baseTypeFrom) + "To" + title(baseTypeTo)
					} else {
						convertFunc = "ptr"
						castToType = baseTypeTo
					}
				}
			}
		case "Boolean":
			if !field.ValueOptional {
				convertFunc = "ptr"
			}
		case "Object":
			fieldName := title(field.ValueName)
			if strings.HasPrefix(field.ValueType, "Array<") {
				fieldName = fieldName[:len(fieldName)-1]
			}
			var typeName string
			if _, ok := existingObjectTypes[fieldName]; ok {
				typeName = jen.Id("*").Qual("github.com/andreykaipov/goobs/api/typedefs", fieldName).GoString()
			} else {
				typeName = "map[string]any"
			}
			convertFunc = fmt.Sprintf("fromAbstractObject[%s]", typeName)
		}
		if castToType != "" {
			src = jen.Params(jen.Id(castToType)).Params(src)
		}
		if convertFunc != "" {
			src = jen.Id(convertFunc).Call(src)
		}
		assignField = assignField.Add(src).Op(",")
		requestFieldAssigns = append(
			requestFieldAssigns,
			assignField,
		)
	}

	var responseFieldAssigns []jen.Code
	for _, field := range request.ResponseFields {
		assignField := jen.Id(title(obsprotobufgen.FieldNameObs2Protobuf(field.ValueName))).Op(":")
		src := jen.Id("resp").Dot(title(field.ValueName))
		switch field.ValueType {
		case "Any":
			src = jen.Id("anyGo2Protobuf").Call(src)
		case "Boolean":
		case "String":
			typeName := obsprotobufgen.TypeNameObs2Protobuf(field.ValueType, field.ValueName, existingObjectTypes)
			if typeName == "bytes" {
				src = jen.Params(jen.Id("[]byte")).Call(src)
			}
		case "Number":
			if !obsprotobufgen.IsFloatNumber(field.ValueName) {
				src = jen.Params(jen.Id("int64")).Call(src)
			}
		case "Array<String>":
			typeName := obsprotobufgen.TypeNameObs2Protobuf(field.ValueType, field.ValueName, existingObjectTypes)
			switch typeName {
			case "repeated bytes":
				src = jen.Id("stringSlice2BytesSlice").Call(src)
			}
		default:
			fieldName := title(field.ValueName)
			if strings.HasPrefix(field.ValueType, "Array<") {
				fieldName = fieldName[:len(fieldName)-1]
			}
			var typeName string
			if _, ok := existingObjectTypes[fieldName]; ok {
				typeName = jen.Id("*").Qual("github.com/andreykaipov/goobs/api/typedefs", fieldName).GoString()
			} else {
				typeName = "map[string]any"
			}

			if strings.HasPrefix(field.ValueType, "Array<") {
				src = jen.Id(fmt.Sprintf("toAbstractObjects[%s]", typeName)).Call(src)
			} else {
				src = jen.Id(fmt.Sprintf("toAbstractObject[%s]", typeName)).Call(src)
			}
		}
		assignField = assignField.Add(src).Op(",")
		responseFieldAssigns = append(
			responseFieldAssigns,
			assignField,
		)
	}

	respID := "resp"
	respOp := ":="
	if len(responseFieldAssigns) == 0 {
		respID = "_"
		respOp = "="
	}

	code.Func().Params(jen.Id("p").Op("*").Id("Proxy")).Id(request.RequestType).Params(
		jen.Id("ctx").Qual("context", "Context"),
		jen.Id("req").Op("*").Qual("github.com/xaionaro-go/obs-grpc-proxy/protobuf/go/obs_grpc", request.RequestType+"Request"),
	).Params(
		jen.Op("*").Qual("github.com/xaionaro-go/obs-grpc-proxy/protobuf/go/obs_grpc", request.RequestType+"Response"),
		jen.Error(),
	).Block(
		jen.List(jen.Id("client"), jen.Id("onFinish"), jen.Id("err")).Op(":=").Id("p").Dot("GetClient").Call(),
		jen.If(jen.Id("onFinish").Op("!=").Nil()).Block(
			jen.Defer().Id("onFinish").Call(),
		),
		jen.If(jen.Id("err").Op("!=").Nil()).Block(jen.Return(jen.List(jen.Nil(), jen.Qual("fmt", "Errorf").Params(jen.Lit("unable to get a client: %w"), jen.Id("err"))))),
		jen.Id("params").Op(":=").Op("&").Qual("github.com/andreykaipov/goobs/api/requests/"+categoryObs2GoPkgName(request.Category), request.RequestType+"Params").Block(
			requestFieldAssigns...,
		),
		jen.List(jen.Id(respID), jen.Id("err")).Op(respOp).Id("client").Dot(categoryObs2Go(request.Category)).Dot(request.RequestType).Call(
			jen.Id("params"),
		),
		jen.If(jen.Id("err").Op("!=").Nil()).Block(jen.Return(jen.List(jen.Nil(), jen.Id("err")))),
		jen.Id("result").Op(":=").Op("&").Qual("github.com/xaionaro-go/obs-grpc-proxy/protobuf/go/obs_grpc", request.RequestType+"Response").Block(responseFieldAssigns...),
		jen.Return(jen.List(jen.Id("result"), jen.Nil())),
	)
	return nil
}

func title(s string) string {
	if len(s) == 0 {
		return ""
	}

	return strings.ToUpper(s[:1]) + s[1:]
}

func categoryObs2Go(obsCat string) string {
	words := strings.Split(obsCat, " ")
	for idx := range words {
		words[idx] = title(words[idx])
	}
	return strings.Join(words, "")
}

func categoryObs2GoPkgName(obsCat string) string {
	words := strings.Split(obsCat, " ")
	for idx := range words {
		words[idx] = strings.ToLower(words[idx])
	}
	return strings.Join(words, "")
}
