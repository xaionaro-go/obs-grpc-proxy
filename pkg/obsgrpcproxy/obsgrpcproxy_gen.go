// This file was automatically generated by github.com/xaionaro-go/obs-grpc-proxy/scripts/generate

package obsgrpcproxy

import (
	"context"
	"fmt"
	config "github.com/andreykaipov/goobs/api/requests/config"
	filters "github.com/andreykaipov/goobs/api/requests/filters"
	general "github.com/andreykaipov/goobs/api/requests/general"
	inputs "github.com/andreykaipov/goobs/api/requests/inputs"
	mediainputs "github.com/andreykaipov/goobs/api/requests/mediainputs"
	outputs "github.com/andreykaipov/goobs/api/requests/outputs"
	record "github.com/andreykaipov/goobs/api/requests/record"
	sceneitems "github.com/andreykaipov/goobs/api/requests/sceneitems"
	scenes "github.com/andreykaipov/goobs/api/requests/scenes"
	sources "github.com/andreykaipov/goobs/api/requests/sources"
	stream "github.com/andreykaipov/goobs/api/requests/stream"
	transitions "github.com/andreykaipov/goobs/api/requests/transitions"
	ui "github.com/andreykaipov/goobs/api/requests/ui"
	typedefs "github.com/andreykaipov/goobs/api/typedefs"
	logger "github.com/facebookincubator/go-belt/tool/logger"
	obsgrpc "github.com/xaionaro-go/obs-grpc-proxy/protobuf/go/obs_grpc"
	grpc "google.golang.org/grpc"
	"runtime/debug"
)

var _ = (*typedefs.Input)(nil)

func (p *Proxy) GetPersistentData(ctx context.Context, req *obsgrpc.GetPersistentDataRequest) (_ret *obsgrpc.GetPersistentDataResponse, _err error) {
	logger.Debugf(ctx, "GetPersistentData")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/GetPersistentData: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &config.GetPersistentDataParams{}
	if req != nil {
		params = &config.GetPersistentDataParams{
			Realm:    ptr((string)(req.Realm)),
			SlotName: ptr(req.SlotName),
		}
	}
	resp, err := client.Config.GetPersistentData(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.GetPersistentDataResponse{
		SlotValue: anyGo2Protobuf(resp.SlotValue),
	}
	return result, nil
}
func (p *ProxyAsClient) GetPersistentData(ctx context.Context, req *obsgrpc.GetPersistentDataRequest, opts ...grpc.CallOption) (*obsgrpc.GetPersistentDataResponse, error) {
	return (*Proxy)(p).GetPersistentData(ctx, req)
}
func (p *ClientAsServer) GetPersistentData(ctx context.Context, req *obsgrpc.GetPersistentDataRequest) (*obsgrpc.GetPersistentDataResponse, error) {
	return p.OBSClient.GetPersistentData(ctx, req)
}
func (p *Proxy) SetPersistentData(ctx context.Context, req *obsgrpc.SetPersistentDataRequest) (_ret *obsgrpc.SetPersistentDataResponse, _err error) {
	logger.Debugf(ctx, "SetPersistentData")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/SetPersistentData: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &config.SetPersistentDataParams{}
	if req != nil {
		params = &config.SetPersistentDataParams{
			Realm:     ptr((string)(req.Realm)),
			SlotName:  ptr(req.SlotName),
			SlotValue: req.SlotValue,
		}
	}
	resp, err := client.Config.SetPersistentData(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.SetPersistentDataResponse{}
	return result, nil
}
func (p *ProxyAsClient) SetPersistentData(ctx context.Context, req *obsgrpc.SetPersistentDataRequest, opts ...grpc.CallOption) (*obsgrpc.SetPersistentDataResponse, error) {
	return (*Proxy)(p).SetPersistentData(ctx, req)
}
func (p *ClientAsServer) SetPersistentData(ctx context.Context, req *obsgrpc.SetPersistentDataRequest) (*obsgrpc.SetPersistentDataResponse, error) {
	return p.OBSClient.SetPersistentData(ctx, req)
}
func (p *Proxy) GetSceneCollectionList(ctx context.Context, req *obsgrpc.GetSceneCollectionListRequest) (_ret *obsgrpc.GetSceneCollectionListResponse, _err error) {
	logger.Debugf(ctx, "GetSceneCollectionList")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/GetSceneCollectionList: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &config.GetSceneCollectionListParams{}
	if req != nil {
		params = &config.GetSceneCollectionListParams{}
	}
	resp, err := client.Config.GetSceneCollectionList(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.GetSceneCollectionListResponse{
		CurrentSceneCollectionName: resp.CurrentSceneCollectionName,
		SceneCollections:           stringSlice2BytesSlice(resp.SceneCollections),
	}
	return result, nil
}
func (p *ProxyAsClient) GetSceneCollectionList(ctx context.Context, req *obsgrpc.GetSceneCollectionListRequest, opts ...grpc.CallOption) (*obsgrpc.GetSceneCollectionListResponse, error) {
	return (*Proxy)(p).GetSceneCollectionList(ctx, req)
}
func (p *ClientAsServer) GetSceneCollectionList(ctx context.Context, req *obsgrpc.GetSceneCollectionListRequest) (*obsgrpc.GetSceneCollectionListResponse, error) {
	return p.OBSClient.GetSceneCollectionList(ctx, req)
}
func (p *Proxy) SetCurrentSceneCollection(ctx context.Context, req *obsgrpc.SetCurrentSceneCollectionRequest) (_ret *obsgrpc.SetCurrentSceneCollectionResponse, _err error) {
	logger.Debugf(ctx, "SetCurrentSceneCollection")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/SetCurrentSceneCollection: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &config.SetCurrentSceneCollectionParams{}
	if req != nil {
		params = &config.SetCurrentSceneCollectionParams{
			SceneCollectionName: ptr(req.SceneCollectionName),
		}
	}
	resp, err := client.Config.SetCurrentSceneCollection(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.SetCurrentSceneCollectionResponse{}
	return result, nil
}
func (p *ProxyAsClient) SetCurrentSceneCollection(ctx context.Context, req *obsgrpc.SetCurrentSceneCollectionRequest, opts ...grpc.CallOption) (*obsgrpc.SetCurrentSceneCollectionResponse, error) {
	return (*Proxy)(p).SetCurrentSceneCollection(ctx, req)
}
func (p *ClientAsServer) SetCurrentSceneCollection(ctx context.Context, req *obsgrpc.SetCurrentSceneCollectionRequest) (*obsgrpc.SetCurrentSceneCollectionResponse, error) {
	return p.OBSClient.SetCurrentSceneCollection(ctx, req)
}
func (p *Proxy) CreateSceneCollection(ctx context.Context, req *obsgrpc.CreateSceneCollectionRequest) (_ret *obsgrpc.CreateSceneCollectionResponse, _err error) {
	logger.Debugf(ctx, "CreateSceneCollection")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/CreateSceneCollection: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &config.CreateSceneCollectionParams{}
	if req != nil {
		params = &config.CreateSceneCollectionParams{
			SceneCollectionName: ptr(req.SceneCollectionName),
		}
	}
	resp, err := client.Config.CreateSceneCollection(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.CreateSceneCollectionResponse{}
	return result, nil
}
func (p *ProxyAsClient) CreateSceneCollection(ctx context.Context, req *obsgrpc.CreateSceneCollectionRequest, opts ...grpc.CallOption) (*obsgrpc.CreateSceneCollectionResponse, error) {
	return (*Proxy)(p).CreateSceneCollection(ctx, req)
}
func (p *ClientAsServer) CreateSceneCollection(ctx context.Context, req *obsgrpc.CreateSceneCollectionRequest) (*obsgrpc.CreateSceneCollectionResponse, error) {
	return p.OBSClient.CreateSceneCollection(ctx, req)
}
func (p *Proxy) GetProfileList(ctx context.Context, req *obsgrpc.GetProfileListRequest) (_ret *obsgrpc.GetProfileListResponse, _err error) {
	logger.Debugf(ctx, "GetProfileList")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/GetProfileList: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &config.GetProfileListParams{}
	if req != nil {
		params = &config.GetProfileListParams{}
	}
	resp, err := client.Config.GetProfileList(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.GetProfileListResponse{
		CurrentProfileName: resp.CurrentProfileName,
		Profiles:           stringSlice2BytesSlice(resp.Profiles),
	}
	return result, nil
}
func (p *ProxyAsClient) GetProfileList(ctx context.Context, req *obsgrpc.GetProfileListRequest, opts ...grpc.CallOption) (*obsgrpc.GetProfileListResponse, error) {
	return (*Proxy)(p).GetProfileList(ctx, req)
}
func (p *ClientAsServer) GetProfileList(ctx context.Context, req *obsgrpc.GetProfileListRequest) (*obsgrpc.GetProfileListResponse, error) {
	return p.OBSClient.GetProfileList(ctx, req)
}
func (p *Proxy) SetCurrentProfile(ctx context.Context, req *obsgrpc.SetCurrentProfileRequest) (_ret *obsgrpc.SetCurrentProfileResponse, _err error) {
	logger.Debugf(ctx, "SetCurrentProfile")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/SetCurrentProfile: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &config.SetCurrentProfileParams{}
	if req != nil {
		params = &config.SetCurrentProfileParams{
			ProfileName: ptr(req.ProfileName),
		}
	}
	resp, err := client.Config.SetCurrentProfile(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.SetCurrentProfileResponse{}
	return result, nil
}
func (p *ProxyAsClient) SetCurrentProfile(ctx context.Context, req *obsgrpc.SetCurrentProfileRequest, opts ...grpc.CallOption) (*obsgrpc.SetCurrentProfileResponse, error) {
	return (*Proxy)(p).SetCurrentProfile(ctx, req)
}
func (p *ClientAsServer) SetCurrentProfile(ctx context.Context, req *obsgrpc.SetCurrentProfileRequest) (*obsgrpc.SetCurrentProfileResponse, error) {
	return p.OBSClient.SetCurrentProfile(ctx, req)
}
func (p *Proxy) CreateProfile(ctx context.Context, req *obsgrpc.CreateProfileRequest) (_ret *obsgrpc.CreateProfileResponse, _err error) {
	logger.Debugf(ctx, "CreateProfile")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/CreateProfile: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &config.CreateProfileParams{}
	if req != nil {
		params = &config.CreateProfileParams{
			ProfileName: ptr(req.ProfileName),
		}
	}
	resp, err := client.Config.CreateProfile(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.CreateProfileResponse{}
	return result, nil
}
func (p *ProxyAsClient) CreateProfile(ctx context.Context, req *obsgrpc.CreateProfileRequest, opts ...grpc.CallOption) (*obsgrpc.CreateProfileResponse, error) {
	return (*Proxy)(p).CreateProfile(ctx, req)
}
func (p *ClientAsServer) CreateProfile(ctx context.Context, req *obsgrpc.CreateProfileRequest) (*obsgrpc.CreateProfileResponse, error) {
	return p.OBSClient.CreateProfile(ctx, req)
}
func (p *Proxy) RemoveProfile(ctx context.Context, req *obsgrpc.RemoveProfileRequest) (_ret *obsgrpc.RemoveProfileResponse, _err error) {
	logger.Debugf(ctx, "RemoveProfile")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/RemoveProfile: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &config.RemoveProfileParams{}
	if req != nil {
		params = &config.RemoveProfileParams{
			ProfileName: ptr(req.ProfileName),
		}
	}
	resp, err := client.Config.RemoveProfile(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.RemoveProfileResponse{}
	return result, nil
}
func (p *ProxyAsClient) RemoveProfile(ctx context.Context, req *obsgrpc.RemoveProfileRequest, opts ...grpc.CallOption) (*obsgrpc.RemoveProfileResponse, error) {
	return (*Proxy)(p).RemoveProfile(ctx, req)
}
func (p *ClientAsServer) RemoveProfile(ctx context.Context, req *obsgrpc.RemoveProfileRequest) (*obsgrpc.RemoveProfileResponse, error) {
	return p.OBSClient.RemoveProfile(ctx, req)
}
func (p *Proxy) GetProfileParameter(ctx context.Context, req *obsgrpc.GetProfileParameterRequest) (_ret *obsgrpc.GetProfileParameterResponse, _err error) {
	logger.Debugf(ctx, "GetProfileParameter")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/GetProfileParameter: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &config.GetProfileParameterParams{}
	if req != nil {
		params = &config.GetProfileParameterParams{
			ParameterCategory: ptr((string)(req.ParameterCategory)),
			ParameterName:     ptr(req.ParameterName),
		}
	}
	resp, err := client.Config.GetProfileParameter(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.GetProfileParameterResponse{
		ParameterValue:        ([]byte)(resp.ParameterValue),
		DefaultParameterValue: ([]byte)(resp.DefaultParameterValue),
	}
	return result, nil
}
func (p *ProxyAsClient) GetProfileParameter(ctx context.Context, req *obsgrpc.GetProfileParameterRequest, opts ...grpc.CallOption) (*obsgrpc.GetProfileParameterResponse, error) {
	return (*Proxy)(p).GetProfileParameter(ctx, req)
}
func (p *ClientAsServer) GetProfileParameter(ctx context.Context, req *obsgrpc.GetProfileParameterRequest) (*obsgrpc.GetProfileParameterResponse, error) {
	return p.OBSClient.GetProfileParameter(ctx, req)
}
func (p *Proxy) SetProfileParameter(ctx context.Context, req *obsgrpc.SetProfileParameterRequest) (_ret *obsgrpc.SetProfileParameterResponse, _err error) {
	logger.Debugf(ctx, "SetProfileParameter")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/SetProfileParameter: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &config.SetProfileParameterParams{}
	if req != nil {
		params = &config.SetProfileParameterParams{
			ParameterCategory: ptr((string)(req.ParameterCategory)),
			ParameterName:     ptr(req.ParameterName),
			ParameterValue:    ptr((string)(req.ParameterValue)),
		}
	}
	resp, err := client.Config.SetProfileParameter(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.SetProfileParameterResponse{}
	return result, nil
}
func (p *ProxyAsClient) SetProfileParameter(ctx context.Context, req *obsgrpc.SetProfileParameterRequest, opts ...grpc.CallOption) (*obsgrpc.SetProfileParameterResponse, error) {
	return (*Proxy)(p).SetProfileParameter(ctx, req)
}
func (p *ClientAsServer) SetProfileParameter(ctx context.Context, req *obsgrpc.SetProfileParameterRequest) (*obsgrpc.SetProfileParameterResponse, error) {
	return p.OBSClient.SetProfileParameter(ctx, req)
}
func (p *Proxy) GetVideoSettings(ctx context.Context, req *obsgrpc.GetVideoSettingsRequest) (_ret *obsgrpc.GetVideoSettingsResponse, _err error) {
	logger.Debugf(ctx, "GetVideoSettings")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/GetVideoSettings: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &config.GetVideoSettingsParams{}
	if req != nil {
		params = &config.GetVideoSettingsParams{}
	}
	resp, err := client.Config.GetVideoSettings(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.GetVideoSettingsResponse{
		FpsNumerator:   (int64)(resp.FpsNumerator),
		FpsDenominator: (int64)(resp.FpsDenominator),
		BaseWidth:      (int64)(resp.BaseWidth),
		BaseHeight:     (int64)(resp.BaseHeight),
		OutputWidth:    (int64)(resp.OutputWidth),
		OutputHeight:   (int64)(resp.OutputHeight),
	}
	return result, nil
}
func (p *ProxyAsClient) GetVideoSettings(ctx context.Context, req *obsgrpc.GetVideoSettingsRequest, opts ...grpc.CallOption) (*obsgrpc.GetVideoSettingsResponse, error) {
	return (*Proxy)(p).GetVideoSettings(ctx, req)
}
func (p *ClientAsServer) GetVideoSettings(ctx context.Context, req *obsgrpc.GetVideoSettingsRequest) (*obsgrpc.GetVideoSettingsResponse, error) {
	return p.OBSClient.GetVideoSettings(ctx, req)
}
func (p *Proxy) SetVideoSettings(ctx context.Context, req *obsgrpc.SetVideoSettingsRequest) (_ret *obsgrpc.SetVideoSettingsResponse, _err error) {
	logger.Debugf(ctx, "SetVideoSettings")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/SetVideoSettings: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &config.SetVideoSettingsParams{}
	if req != nil {
		params = &config.SetVideoSettingsParams{
			FpsNumerator:   ptrInt64ToFloat64(req.FpsNumerator),
			FpsDenominator: ptrInt64ToFloat64(req.FpsDenominator),
			BaseWidth:      ptrInt64ToFloat64(req.BaseWidth),
			BaseHeight:     ptrInt64ToFloat64(req.BaseHeight),
			OutputWidth:    ptrInt64ToFloat64(req.OutputWidth),
			OutputHeight:   ptrInt64ToFloat64(req.OutputHeight),
		}
	}
	resp, err := client.Config.SetVideoSettings(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.SetVideoSettingsResponse{}
	return result, nil
}
func (p *ProxyAsClient) SetVideoSettings(ctx context.Context, req *obsgrpc.SetVideoSettingsRequest, opts ...grpc.CallOption) (*obsgrpc.SetVideoSettingsResponse, error) {
	return (*Proxy)(p).SetVideoSettings(ctx, req)
}
func (p *ClientAsServer) SetVideoSettings(ctx context.Context, req *obsgrpc.SetVideoSettingsRequest) (*obsgrpc.SetVideoSettingsResponse, error) {
	return p.OBSClient.SetVideoSettings(ctx, req)
}
func (p *Proxy) GetStreamServiceSettings(ctx context.Context, req *obsgrpc.GetStreamServiceSettingsRequest) (_ret *obsgrpc.GetStreamServiceSettingsResponse, _err error) {
	logger.Debugf(ctx, "GetStreamServiceSettings")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/GetStreamServiceSettings: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &config.GetStreamServiceSettingsParams{}
	if req != nil {
		params = &config.GetStreamServiceSettingsParams{}
	}
	resp, err := client.Config.GetStreamServiceSettings(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.GetStreamServiceSettingsResponse{
		StreamServiceType:     ([]byte)(resp.StreamServiceType),
		StreamServiceSettings: toAbstractObject[*typedefs.StreamServiceSettings](resp.StreamServiceSettings),
	}
	return result, nil
}
func (p *ProxyAsClient) GetStreamServiceSettings(ctx context.Context, req *obsgrpc.GetStreamServiceSettingsRequest, opts ...grpc.CallOption) (*obsgrpc.GetStreamServiceSettingsResponse, error) {
	return (*Proxy)(p).GetStreamServiceSettings(ctx, req)
}
func (p *ClientAsServer) GetStreamServiceSettings(ctx context.Context, req *obsgrpc.GetStreamServiceSettingsRequest) (*obsgrpc.GetStreamServiceSettingsResponse, error) {
	return p.OBSClient.GetStreamServiceSettings(ctx, req)
}
func (p *Proxy) SetStreamServiceSettings(ctx context.Context, req *obsgrpc.SetStreamServiceSettingsRequest) (_ret *obsgrpc.SetStreamServiceSettingsResponse, _err error) {
	logger.Debugf(ctx, "SetStreamServiceSettings")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/SetStreamServiceSettings: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &config.SetStreamServiceSettingsParams{}
	if req != nil {
		params = &config.SetStreamServiceSettingsParams{
			StreamServiceType:     ptr((string)(req.StreamServiceType)),
			StreamServiceSettings: fromAbstractObject[*typedefs.StreamServiceSettings](req.StreamServiceSettings),
		}
	}
	resp, err := client.Config.SetStreamServiceSettings(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.SetStreamServiceSettingsResponse{}
	return result, nil
}
func (p *ProxyAsClient) SetStreamServiceSettings(ctx context.Context, req *obsgrpc.SetStreamServiceSettingsRequest, opts ...grpc.CallOption) (*obsgrpc.SetStreamServiceSettingsResponse, error) {
	return (*Proxy)(p).SetStreamServiceSettings(ctx, req)
}
func (p *ClientAsServer) SetStreamServiceSettings(ctx context.Context, req *obsgrpc.SetStreamServiceSettingsRequest) (*obsgrpc.SetStreamServiceSettingsResponse, error) {
	return p.OBSClient.SetStreamServiceSettings(ctx, req)
}
func (p *Proxy) GetRecordDirectory(ctx context.Context, req *obsgrpc.GetRecordDirectoryRequest) (_ret *obsgrpc.GetRecordDirectoryResponse, _err error) {
	logger.Debugf(ctx, "GetRecordDirectory")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/GetRecordDirectory: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &config.GetRecordDirectoryParams{}
	if req != nil {
		params = &config.GetRecordDirectoryParams{}
	}
	resp, err := client.Config.GetRecordDirectory(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.GetRecordDirectoryResponse{
		RecordDirectory: ([]byte)(resp.RecordDirectory),
	}
	return result, nil
}
func (p *ProxyAsClient) GetRecordDirectory(ctx context.Context, req *obsgrpc.GetRecordDirectoryRequest, opts ...grpc.CallOption) (*obsgrpc.GetRecordDirectoryResponse, error) {
	return (*Proxy)(p).GetRecordDirectory(ctx, req)
}
func (p *ClientAsServer) GetRecordDirectory(ctx context.Context, req *obsgrpc.GetRecordDirectoryRequest) (*obsgrpc.GetRecordDirectoryResponse, error) {
	return p.OBSClient.GetRecordDirectory(ctx, req)
}
func (p *Proxy) SetRecordDirectory(ctx context.Context, req *obsgrpc.SetRecordDirectoryRequest) (_ret *obsgrpc.SetRecordDirectoryResponse, _err error) {
	logger.Debugf(ctx, "SetRecordDirectory")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/SetRecordDirectory: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &config.SetRecordDirectoryParams{}
	if req != nil {
		params = &config.SetRecordDirectoryParams{
			RecordDirectory: ptr((string)(req.RecordDirectory)),
		}
	}
	resp, err := client.Config.SetRecordDirectory(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.SetRecordDirectoryResponse{}
	return result, nil
}
func (p *ProxyAsClient) SetRecordDirectory(ctx context.Context, req *obsgrpc.SetRecordDirectoryRequest, opts ...grpc.CallOption) (*obsgrpc.SetRecordDirectoryResponse, error) {
	return (*Proxy)(p).SetRecordDirectory(ctx, req)
}
func (p *ClientAsServer) SetRecordDirectory(ctx context.Context, req *obsgrpc.SetRecordDirectoryRequest) (*obsgrpc.SetRecordDirectoryResponse, error) {
	return p.OBSClient.SetRecordDirectory(ctx, req)
}
func (p *Proxy) GetSourceFilterKindList(ctx context.Context, req *obsgrpc.GetSourceFilterKindListRequest) (_ret *obsgrpc.GetSourceFilterKindListResponse, _err error) {
	logger.Debugf(ctx, "GetSourceFilterKindList")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/GetSourceFilterKindList: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &filters.GetSourceFilterKindListParams{}
	if req != nil {
		params = &filters.GetSourceFilterKindListParams{}
	}
	resp, err := client.Filters.GetSourceFilterKindList(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.GetSourceFilterKindListResponse{
		SourceFilterKinds: resp.SourceFilterKinds,
	}
	return result, nil
}
func (p *ProxyAsClient) GetSourceFilterKindList(ctx context.Context, req *obsgrpc.GetSourceFilterKindListRequest, opts ...grpc.CallOption) (*obsgrpc.GetSourceFilterKindListResponse, error) {
	return (*Proxy)(p).GetSourceFilterKindList(ctx, req)
}
func (p *ClientAsServer) GetSourceFilterKindList(ctx context.Context, req *obsgrpc.GetSourceFilterKindListRequest) (*obsgrpc.GetSourceFilterKindListResponse, error) {
	return p.OBSClient.GetSourceFilterKindList(ctx, req)
}
func (p *Proxy) GetSourceFilterList(ctx context.Context, req *obsgrpc.GetSourceFilterListRequest) (_ret *obsgrpc.GetSourceFilterListResponse, _err error) {
	logger.Debugf(ctx, "GetSourceFilterList")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/GetSourceFilterList: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &filters.GetSourceFilterListParams{}
	if req != nil {
		params = &filters.GetSourceFilterListParams{
			SourceName: req.SourceName,
			SourceUuid: req.SourceUUID,
		}
	}
	resp, err := client.Filters.GetSourceFilterList(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.GetSourceFilterListResponse{
		Filters: toAbstractObjects[*typedefs.Filter](resp.Filters),
	}
	return result, nil
}
func (p *ProxyAsClient) GetSourceFilterList(ctx context.Context, req *obsgrpc.GetSourceFilterListRequest, opts ...grpc.CallOption) (*obsgrpc.GetSourceFilterListResponse, error) {
	return (*Proxy)(p).GetSourceFilterList(ctx, req)
}
func (p *ClientAsServer) GetSourceFilterList(ctx context.Context, req *obsgrpc.GetSourceFilterListRequest) (*obsgrpc.GetSourceFilterListResponse, error) {
	return p.OBSClient.GetSourceFilterList(ctx, req)
}
func (p *Proxy) GetSourceFilterDefaultSettings(ctx context.Context, req *obsgrpc.GetSourceFilterDefaultSettingsRequest) (_ret *obsgrpc.GetSourceFilterDefaultSettingsResponse, _err error) {
	logger.Debugf(ctx, "GetSourceFilterDefaultSettings")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/GetSourceFilterDefaultSettings: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &filters.GetSourceFilterDefaultSettingsParams{}
	if req != nil {
		params = &filters.GetSourceFilterDefaultSettingsParams{
			FilterKind: ptr(req.FilterKind),
		}
	}
	resp, err := client.Filters.GetSourceFilterDefaultSettings(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.GetSourceFilterDefaultSettingsResponse{
		DefaultFilterSettings: toAbstractObject[map[string]any](resp.DefaultFilterSettings),
	}
	return result, nil
}
func (p *ProxyAsClient) GetSourceFilterDefaultSettings(ctx context.Context, req *obsgrpc.GetSourceFilterDefaultSettingsRequest, opts ...grpc.CallOption) (*obsgrpc.GetSourceFilterDefaultSettingsResponse, error) {
	return (*Proxy)(p).GetSourceFilterDefaultSettings(ctx, req)
}
func (p *ClientAsServer) GetSourceFilterDefaultSettings(ctx context.Context, req *obsgrpc.GetSourceFilterDefaultSettingsRequest) (*obsgrpc.GetSourceFilterDefaultSettingsResponse, error) {
	return p.OBSClient.GetSourceFilterDefaultSettings(ctx, req)
}
func (p *Proxy) CreateSourceFilter(ctx context.Context, req *obsgrpc.CreateSourceFilterRequest) (_ret *obsgrpc.CreateSourceFilterResponse, _err error) {
	logger.Debugf(ctx, "CreateSourceFilter")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/CreateSourceFilter: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &filters.CreateSourceFilterParams{}
	if req != nil {
		params = &filters.CreateSourceFilterParams{
			SourceName:     req.SourceName,
			SourceUuid:     req.SourceUUID,
			FilterName:     ptr(req.FilterName),
			FilterKind:     ptr(req.FilterKind),
			FilterSettings: fromAbstractObject[map[string]any](req.FilterSettings),
		}
	}
	resp, err := client.Filters.CreateSourceFilter(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.CreateSourceFilterResponse{}
	return result, nil
}
func (p *ProxyAsClient) CreateSourceFilter(ctx context.Context, req *obsgrpc.CreateSourceFilterRequest, opts ...grpc.CallOption) (*obsgrpc.CreateSourceFilterResponse, error) {
	return (*Proxy)(p).CreateSourceFilter(ctx, req)
}
func (p *ClientAsServer) CreateSourceFilter(ctx context.Context, req *obsgrpc.CreateSourceFilterRequest) (*obsgrpc.CreateSourceFilterResponse, error) {
	return p.OBSClient.CreateSourceFilter(ctx, req)
}
func (p *Proxy) RemoveSourceFilter(ctx context.Context, req *obsgrpc.RemoveSourceFilterRequest) (_ret *obsgrpc.RemoveSourceFilterResponse, _err error) {
	logger.Debugf(ctx, "RemoveSourceFilter")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/RemoveSourceFilter: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &filters.RemoveSourceFilterParams{}
	if req != nil {
		params = &filters.RemoveSourceFilterParams{
			SourceName: req.SourceName,
			SourceUuid: req.SourceUUID,
			FilterName: ptr(req.FilterName),
		}
	}
	resp, err := client.Filters.RemoveSourceFilter(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.RemoveSourceFilterResponse{}
	return result, nil
}
func (p *ProxyAsClient) RemoveSourceFilter(ctx context.Context, req *obsgrpc.RemoveSourceFilterRequest, opts ...grpc.CallOption) (*obsgrpc.RemoveSourceFilterResponse, error) {
	return (*Proxy)(p).RemoveSourceFilter(ctx, req)
}
func (p *ClientAsServer) RemoveSourceFilter(ctx context.Context, req *obsgrpc.RemoveSourceFilterRequest) (*obsgrpc.RemoveSourceFilterResponse, error) {
	return p.OBSClient.RemoveSourceFilter(ctx, req)
}
func (p *Proxy) SetSourceFilterName(ctx context.Context, req *obsgrpc.SetSourceFilterNameRequest) (_ret *obsgrpc.SetSourceFilterNameResponse, _err error) {
	logger.Debugf(ctx, "SetSourceFilterName")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/SetSourceFilterName: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &filters.SetSourceFilterNameParams{}
	if req != nil {
		params = &filters.SetSourceFilterNameParams{
			SourceName:    req.SourceName,
			SourceUuid:    req.SourceUUID,
			FilterName:    ptr(req.FilterName),
			NewFilterName: ptr(req.NewFilterName),
		}
	}
	resp, err := client.Filters.SetSourceFilterName(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.SetSourceFilterNameResponse{}
	return result, nil
}
func (p *ProxyAsClient) SetSourceFilterName(ctx context.Context, req *obsgrpc.SetSourceFilterNameRequest, opts ...grpc.CallOption) (*obsgrpc.SetSourceFilterNameResponse, error) {
	return (*Proxy)(p).SetSourceFilterName(ctx, req)
}
func (p *ClientAsServer) SetSourceFilterName(ctx context.Context, req *obsgrpc.SetSourceFilterNameRequest) (*obsgrpc.SetSourceFilterNameResponse, error) {
	return p.OBSClient.SetSourceFilterName(ctx, req)
}
func (p *Proxy) GetSourceFilter(ctx context.Context, req *obsgrpc.GetSourceFilterRequest) (_ret *obsgrpc.GetSourceFilterResponse, _err error) {
	logger.Debugf(ctx, "GetSourceFilter")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/GetSourceFilter: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &filters.GetSourceFilterParams{}
	if req != nil {
		params = &filters.GetSourceFilterParams{
			SourceName: req.SourceName,
			SourceUuid: req.SourceUUID,
			FilterName: ptr(req.FilterName),
		}
	}
	resp, err := client.Filters.GetSourceFilter(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.GetSourceFilterResponse{
		FilterEnabled:  resp.FilterEnabled,
		FilterIndex:    (int64)(resp.FilterIndex),
		FilterKind:     resp.FilterKind,
		FilterSettings: toAbstractObject[map[string]any](resp.FilterSettings),
	}
	return result, nil
}
func (p *ProxyAsClient) GetSourceFilter(ctx context.Context, req *obsgrpc.GetSourceFilterRequest, opts ...grpc.CallOption) (*obsgrpc.GetSourceFilterResponse, error) {
	return (*Proxy)(p).GetSourceFilter(ctx, req)
}
func (p *ClientAsServer) GetSourceFilter(ctx context.Context, req *obsgrpc.GetSourceFilterRequest) (*obsgrpc.GetSourceFilterResponse, error) {
	return p.OBSClient.GetSourceFilter(ctx, req)
}
func (p *Proxy) SetSourceFilterIndex(ctx context.Context, req *obsgrpc.SetSourceFilterIndexRequest) (_ret *obsgrpc.SetSourceFilterIndexResponse, _err error) {
	logger.Debugf(ctx, "SetSourceFilterIndex")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/SetSourceFilterIndex: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &filters.SetSourceFilterIndexParams{}
	if req != nil {
		params = &filters.SetSourceFilterIndexParams{
			SourceName:  req.SourceName,
			SourceUuid:  req.SourceUUID,
			FilterName:  ptr(req.FilterName),
			FilterIndex: ptr((int)(req.FilterIndex)),
		}
	}
	resp, err := client.Filters.SetSourceFilterIndex(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.SetSourceFilterIndexResponse{}
	return result, nil
}
func (p *ProxyAsClient) SetSourceFilterIndex(ctx context.Context, req *obsgrpc.SetSourceFilterIndexRequest, opts ...grpc.CallOption) (*obsgrpc.SetSourceFilterIndexResponse, error) {
	return (*Proxy)(p).SetSourceFilterIndex(ctx, req)
}
func (p *ClientAsServer) SetSourceFilterIndex(ctx context.Context, req *obsgrpc.SetSourceFilterIndexRequest) (*obsgrpc.SetSourceFilterIndexResponse, error) {
	return p.OBSClient.SetSourceFilterIndex(ctx, req)
}
func (p *Proxy) SetSourceFilterSettings(ctx context.Context, req *obsgrpc.SetSourceFilterSettingsRequest) (_ret *obsgrpc.SetSourceFilterSettingsResponse, _err error) {
	logger.Debugf(ctx, "SetSourceFilterSettings")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/SetSourceFilterSettings: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &filters.SetSourceFilterSettingsParams{}
	if req != nil {
		params = &filters.SetSourceFilterSettingsParams{
			SourceName:     req.SourceName,
			SourceUuid:     req.SourceUUID,
			FilterName:     ptr(req.FilterName),
			FilterSettings: fromAbstractObject[map[string]any](req.FilterSettings),
			Overlay:        req.Overlay,
		}
	}
	resp, err := client.Filters.SetSourceFilterSettings(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.SetSourceFilterSettingsResponse{}
	return result, nil
}
func (p *ProxyAsClient) SetSourceFilterSettings(ctx context.Context, req *obsgrpc.SetSourceFilterSettingsRequest, opts ...grpc.CallOption) (*obsgrpc.SetSourceFilterSettingsResponse, error) {
	return (*Proxy)(p).SetSourceFilterSettings(ctx, req)
}
func (p *ClientAsServer) SetSourceFilterSettings(ctx context.Context, req *obsgrpc.SetSourceFilterSettingsRequest) (*obsgrpc.SetSourceFilterSettingsResponse, error) {
	return p.OBSClient.SetSourceFilterSettings(ctx, req)
}
func (p *Proxy) SetSourceFilterEnabled(ctx context.Context, req *obsgrpc.SetSourceFilterEnabledRequest) (_ret *obsgrpc.SetSourceFilterEnabledResponse, _err error) {
	logger.Debugf(ctx, "SetSourceFilterEnabled")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/SetSourceFilterEnabled: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &filters.SetSourceFilterEnabledParams{}
	if req != nil {
		params = &filters.SetSourceFilterEnabledParams{
			SourceName:    req.SourceName,
			SourceUuid:    req.SourceUUID,
			FilterName:    ptr(req.FilterName),
			FilterEnabled: ptr(req.FilterEnabled),
		}
	}
	resp, err := client.Filters.SetSourceFilterEnabled(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.SetSourceFilterEnabledResponse{}
	return result, nil
}
func (p *ProxyAsClient) SetSourceFilterEnabled(ctx context.Context, req *obsgrpc.SetSourceFilterEnabledRequest, opts ...grpc.CallOption) (*obsgrpc.SetSourceFilterEnabledResponse, error) {
	return (*Proxy)(p).SetSourceFilterEnabled(ctx, req)
}
func (p *ClientAsServer) SetSourceFilterEnabled(ctx context.Context, req *obsgrpc.SetSourceFilterEnabledRequest) (*obsgrpc.SetSourceFilterEnabledResponse, error) {
	return p.OBSClient.SetSourceFilterEnabled(ctx, req)
}
func (p *Proxy) GetVersion(ctx context.Context, req *obsgrpc.GetVersionRequest) (_ret *obsgrpc.GetVersionResponse, _err error) {
	logger.Debugf(ctx, "GetVersion")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/GetVersion: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &general.GetVersionParams{}
	if req != nil {
		params = &general.GetVersionParams{}
	}
	resp, err := client.General.GetVersion(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.GetVersionResponse{
		ObsVersion:            ([]byte)(resp.ObsVersion),
		ObsWebSocketVersion:   ([]byte)(resp.ObsWebSocketVersion),
		RpcVersion:            (int64)(resp.RpcVersion),
		AvailableRequests:     stringSlice2BytesSlice(resp.AvailableRequests),
		SupportedImageFormats: stringSlice2BytesSlice(resp.SupportedImageFormats),
		Platform:              ([]byte)(resp.Platform),
		PlatformDescription:   ([]byte)(resp.PlatformDescription),
	}
	return result, nil
}
func (p *ProxyAsClient) GetVersion(ctx context.Context, req *obsgrpc.GetVersionRequest, opts ...grpc.CallOption) (*obsgrpc.GetVersionResponse, error) {
	return (*Proxy)(p).GetVersion(ctx, req)
}
func (p *ClientAsServer) GetVersion(ctx context.Context, req *obsgrpc.GetVersionRequest) (*obsgrpc.GetVersionResponse, error) {
	return p.OBSClient.GetVersion(ctx, req)
}
func (p *Proxy) GetStats(ctx context.Context, req *obsgrpc.GetStatsRequest) (_ret *obsgrpc.GetStatsResponse, _err error) {
	logger.Debugf(ctx, "GetStats")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/GetStats: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &general.GetStatsParams{}
	if req != nil {
		params = &general.GetStatsParams{}
	}
	resp, err := client.General.GetStats(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.GetStatsResponse{
		CpuUsage:                         (int64)(resp.CpuUsage),
		MemoryUsage:                      (int64)(resp.MemoryUsage),
		AvailableDiskSpace:               (int64)(resp.AvailableDiskSpace),
		ActiveFps:                        (int64)(resp.ActiveFps),
		AverageFrameRenderTime:           (int64)(resp.AverageFrameRenderTime),
		RenderSkippedFrames:              (int64)(resp.RenderSkippedFrames),
		RenderTotalFrames:                (int64)(resp.RenderTotalFrames),
		OutputSkippedFrames:              (int64)(resp.OutputSkippedFrames),
		OutputTotalFrames:                (int64)(resp.OutputTotalFrames),
		WebSocketSessionIncomingMessages: (int64)(resp.WebSocketSessionIncomingMessages),
		WebSocketSessionOutgoingMessages: (int64)(resp.WebSocketSessionOutgoingMessages),
	}
	return result, nil
}
func (p *ProxyAsClient) GetStats(ctx context.Context, req *obsgrpc.GetStatsRequest, opts ...grpc.CallOption) (*obsgrpc.GetStatsResponse, error) {
	return (*Proxy)(p).GetStats(ctx, req)
}
func (p *ClientAsServer) GetStats(ctx context.Context, req *obsgrpc.GetStatsRequest) (*obsgrpc.GetStatsResponse, error) {
	return p.OBSClient.GetStats(ctx, req)
}
func (p *Proxy) BroadcastCustomEvent(ctx context.Context, req *obsgrpc.BroadcastCustomEventRequest) (_ret *obsgrpc.BroadcastCustomEventResponse, _err error) {
	logger.Debugf(ctx, "BroadcastCustomEvent")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/BroadcastCustomEvent: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &general.BroadcastCustomEventParams{}
	if req != nil {
		params = &general.BroadcastCustomEventParams{
			EventData: fromAbstractObject[map[string]any](req.EventData),
		}
	}
	resp, err := client.General.BroadcastCustomEvent(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.BroadcastCustomEventResponse{}
	return result, nil
}
func (p *ProxyAsClient) BroadcastCustomEvent(ctx context.Context, req *obsgrpc.BroadcastCustomEventRequest, opts ...grpc.CallOption) (*obsgrpc.BroadcastCustomEventResponse, error) {
	return (*Proxy)(p).BroadcastCustomEvent(ctx, req)
}
func (p *ClientAsServer) BroadcastCustomEvent(ctx context.Context, req *obsgrpc.BroadcastCustomEventRequest) (*obsgrpc.BroadcastCustomEventResponse, error) {
	return p.OBSClient.BroadcastCustomEvent(ctx, req)
}
func (p *Proxy) CallVendorRequest(ctx context.Context, req *obsgrpc.CallVendorRequestRequest) (_ret *obsgrpc.CallVendorRequestResponse, _err error) {
	logger.Debugf(ctx, "CallVendorRequest")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/CallVendorRequest: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &general.CallVendorRequestParams{}
	if req != nil {
		params = &general.CallVendorRequestParams{
			VendorName:  ptr(req.VendorName),
			RequestType: ptr((string)(req.RequestType)),
			RequestData: fromAbstractObject[map[string]any](req.RequestData),
		}
	}
	resp, err := client.General.CallVendorRequest(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.CallVendorRequestResponse{
		VendorName:   resp.VendorName,
		RequestType:  ([]byte)(resp.RequestType),
		ResponseData: toAbstractObject[map[string]any](resp.ResponseData),
	}
	return result, nil
}
func (p *ProxyAsClient) CallVendorRequest(ctx context.Context, req *obsgrpc.CallVendorRequestRequest, opts ...grpc.CallOption) (*obsgrpc.CallVendorRequestResponse, error) {
	return (*Proxy)(p).CallVendorRequest(ctx, req)
}
func (p *ClientAsServer) CallVendorRequest(ctx context.Context, req *obsgrpc.CallVendorRequestRequest) (*obsgrpc.CallVendorRequestResponse, error) {
	return p.OBSClient.CallVendorRequest(ctx, req)
}
func (p *Proxy) GetHotkeyList(ctx context.Context, req *obsgrpc.GetHotkeyListRequest) (_ret *obsgrpc.GetHotkeyListResponse, _err error) {
	logger.Debugf(ctx, "GetHotkeyList")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/GetHotkeyList: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &general.GetHotkeyListParams{}
	if req != nil {
		params = &general.GetHotkeyListParams{}
	}
	resp, err := client.General.GetHotkeyList(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.GetHotkeyListResponse{
		Hotkeys: stringSlice2BytesSlice(resp.Hotkeys),
	}
	return result, nil
}
func (p *ProxyAsClient) GetHotkeyList(ctx context.Context, req *obsgrpc.GetHotkeyListRequest, opts ...grpc.CallOption) (*obsgrpc.GetHotkeyListResponse, error) {
	return (*Proxy)(p).GetHotkeyList(ctx, req)
}
func (p *ClientAsServer) GetHotkeyList(ctx context.Context, req *obsgrpc.GetHotkeyListRequest) (*obsgrpc.GetHotkeyListResponse, error) {
	return p.OBSClient.GetHotkeyList(ctx, req)
}
func (p *Proxy) TriggerHotkeyByName(ctx context.Context, req *obsgrpc.TriggerHotkeyByNameRequest) (_ret *obsgrpc.TriggerHotkeyByNameResponse, _err error) {
	logger.Debugf(ctx, "TriggerHotkeyByName")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/TriggerHotkeyByName: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &general.TriggerHotkeyByNameParams{}
	if req != nil {
		params = &general.TriggerHotkeyByNameParams{
			HotkeyName:  ptr(req.HotkeyName),
			ContextName: req.ContextName,
		}
	}
	resp, err := client.General.TriggerHotkeyByName(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.TriggerHotkeyByNameResponse{}
	return result, nil
}
func (p *ProxyAsClient) TriggerHotkeyByName(ctx context.Context, req *obsgrpc.TriggerHotkeyByNameRequest, opts ...grpc.CallOption) (*obsgrpc.TriggerHotkeyByNameResponse, error) {
	return (*Proxy)(p).TriggerHotkeyByName(ctx, req)
}
func (p *ClientAsServer) TriggerHotkeyByName(ctx context.Context, req *obsgrpc.TriggerHotkeyByNameRequest) (*obsgrpc.TriggerHotkeyByNameResponse, error) {
	return p.OBSClient.TriggerHotkeyByName(ctx, req)
}
func (p *Proxy) TriggerHotkeyByKeySequence(ctx context.Context, req *obsgrpc.TriggerHotkeyByKeySequenceRequest) (_ret *obsgrpc.TriggerHotkeyByKeySequenceResponse, _err error) {
	logger.Debugf(ctx, "TriggerHotkeyByKeySequence")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/TriggerHotkeyByKeySequence: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &general.TriggerHotkeyByKeySequenceParams{}
	if req != nil {
		params = &general.TriggerHotkeyByKeySequenceParams{
			KeyId:        req.KeyID,
			KeyModifiers: fromAbstractObject[*typedefs.KeyModifiers](req.KeyModifiers),
		}
	}
	resp, err := client.General.TriggerHotkeyByKeySequence(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.TriggerHotkeyByKeySequenceResponse{}
	return result, nil
}
func (p *ProxyAsClient) TriggerHotkeyByKeySequence(ctx context.Context, req *obsgrpc.TriggerHotkeyByKeySequenceRequest, opts ...grpc.CallOption) (*obsgrpc.TriggerHotkeyByKeySequenceResponse, error) {
	return (*Proxy)(p).TriggerHotkeyByKeySequence(ctx, req)
}
func (p *ClientAsServer) TriggerHotkeyByKeySequence(ctx context.Context, req *obsgrpc.TriggerHotkeyByKeySequenceRequest) (*obsgrpc.TriggerHotkeyByKeySequenceResponse, error) {
	return p.OBSClient.TriggerHotkeyByKeySequence(ctx, req)
}
func (p *Proxy) Sleep(ctx context.Context, req *obsgrpc.SleepRequest) (_ret *obsgrpc.SleepResponse, _err error) {
	logger.Debugf(ctx, "Sleep")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/Sleep: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &general.SleepParams{}
	if req != nil {
		params = &general.SleepParams{
			SleepMillis: ptrInt64ToFloat64(req.SleepMillis),
			SleepFrames: ptrInt64ToFloat64(req.SleepFrames),
		}
	}
	resp, err := client.General.Sleep(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.SleepResponse{}
	return result, nil
}
func (p *ProxyAsClient) Sleep(ctx context.Context, req *obsgrpc.SleepRequest, opts ...grpc.CallOption) (*obsgrpc.SleepResponse, error) {
	return (*Proxy)(p).Sleep(ctx, req)
}
func (p *ClientAsServer) Sleep(ctx context.Context, req *obsgrpc.SleepRequest) (*obsgrpc.SleepResponse, error) {
	return p.OBSClient.Sleep(ctx, req)
}
func (p *Proxy) GetInputList(ctx context.Context, req *obsgrpc.GetInputListRequest) (_ret *obsgrpc.GetInputListResponse, _err error) {
	logger.Debugf(ctx, "GetInputList")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/GetInputList: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &inputs.GetInputListParams{}
	if req != nil {
		params = &inputs.GetInputListParams{
			InputKind: req.InputKind,
		}
	}
	resp, err := client.Inputs.GetInputList(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.GetInputListResponse{
		Inputs: toAbstractObjects[*typedefs.Input](resp.Inputs),
	}
	return result, nil
}
func (p *ProxyAsClient) GetInputList(ctx context.Context, req *obsgrpc.GetInputListRequest, opts ...grpc.CallOption) (*obsgrpc.GetInputListResponse, error) {
	return (*Proxy)(p).GetInputList(ctx, req)
}
func (p *ClientAsServer) GetInputList(ctx context.Context, req *obsgrpc.GetInputListRequest) (*obsgrpc.GetInputListResponse, error) {
	return p.OBSClient.GetInputList(ctx, req)
}
func (p *Proxy) GetInputKindList(ctx context.Context, req *obsgrpc.GetInputKindListRequest) (_ret *obsgrpc.GetInputKindListResponse, _err error) {
	logger.Debugf(ctx, "GetInputKindList")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/GetInputKindList: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &inputs.GetInputKindListParams{}
	if req != nil {
		params = &inputs.GetInputKindListParams{
			Unversioned: req.Unversioned,
		}
	}
	resp, err := client.Inputs.GetInputKindList(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.GetInputKindListResponse{
		InputKinds: resp.InputKinds,
	}
	return result, nil
}
func (p *ProxyAsClient) GetInputKindList(ctx context.Context, req *obsgrpc.GetInputKindListRequest, opts ...grpc.CallOption) (*obsgrpc.GetInputKindListResponse, error) {
	return (*Proxy)(p).GetInputKindList(ctx, req)
}
func (p *ClientAsServer) GetInputKindList(ctx context.Context, req *obsgrpc.GetInputKindListRequest) (*obsgrpc.GetInputKindListResponse, error) {
	return p.OBSClient.GetInputKindList(ctx, req)
}
func (p *Proxy) GetSpecialInputs(ctx context.Context, req *obsgrpc.GetSpecialInputsRequest) (_ret *obsgrpc.GetSpecialInputsResponse, _err error) {
	logger.Debugf(ctx, "GetSpecialInputs")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/GetSpecialInputs: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &inputs.GetSpecialInputsParams{}
	if req != nil {
		params = &inputs.GetSpecialInputsParams{}
	}
	resp, err := client.Inputs.GetSpecialInputs(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.GetSpecialInputsResponse{
		Desktop1: ([]byte)(resp.Desktop1),
		Desktop2: ([]byte)(resp.Desktop2),
		Mic1:     ([]byte)(resp.Mic1),
		Mic2:     ([]byte)(resp.Mic2),
		Mic3:     ([]byte)(resp.Mic3),
		Mic4:     ([]byte)(resp.Mic4),
	}
	return result, nil
}
func (p *ProxyAsClient) GetSpecialInputs(ctx context.Context, req *obsgrpc.GetSpecialInputsRequest, opts ...grpc.CallOption) (*obsgrpc.GetSpecialInputsResponse, error) {
	return (*Proxy)(p).GetSpecialInputs(ctx, req)
}
func (p *ClientAsServer) GetSpecialInputs(ctx context.Context, req *obsgrpc.GetSpecialInputsRequest) (*obsgrpc.GetSpecialInputsResponse, error) {
	return p.OBSClient.GetSpecialInputs(ctx, req)
}
func (p *Proxy) CreateInput(ctx context.Context, req *obsgrpc.CreateInputRequest) (_ret *obsgrpc.CreateInputResponse, _err error) {
	logger.Debugf(ctx, "CreateInput")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/CreateInput: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &inputs.CreateInputParams{}
	if req != nil {
		params = &inputs.CreateInputParams{
			SceneName:        req.SceneName,
			SceneUuid:        req.SceneUUID,
			InputName:        ptr(req.InputName),
			InputKind:        ptr(req.InputKind),
			InputSettings:    fromAbstractObject[map[string]any](req.InputSettings),
			SceneItemEnabled: req.SceneItemEnabled,
		}
	}
	resp, err := client.Inputs.CreateInput(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.CreateInputResponse{
		InputUUID:   resp.InputUuid,
		SceneItemID: (int64)(resp.SceneItemId),
	}
	return result, nil
}
func (p *ProxyAsClient) CreateInput(ctx context.Context, req *obsgrpc.CreateInputRequest, opts ...grpc.CallOption) (*obsgrpc.CreateInputResponse, error) {
	return (*Proxy)(p).CreateInput(ctx, req)
}
func (p *ClientAsServer) CreateInput(ctx context.Context, req *obsgrpc.CreateInputRequest) (*obsgrpc.CreateInputResponse, error) {
	return p.OBSClient.CreateInput(ctx, req)
}
func (p *Proxy) RemoveInput(ctx context.Context, req *obsgrpc.RemoveInputRequest) (_ret *obsgrpc.RemoveInputResponse, _err error) {
	logger.Debugf(ctx, "RemoveInput")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/RemoveInput: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &inputs.RemoveInputParams{}
	if req != nil {
		params = &inputs.RemoveInputParams{
			InputName: req.InputName,
			InputUuid: req.InputUUID,
		}
	}
	resp, err := client.Inputs.RemoveInput(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.RemoveInputResponse{}
	return result, nil
}
func (p *ProxyAsClient) RemoveInput(ctx context.Context, req *obsgrpc.RemoveInputRequest, opts ...grpc.CallOption) (*obsgrpc.RemoveInputResponse, error) {
	return (*Proxy)(p).RemoveInput(ctx, req)
}
func (p *ClientAsServer) RemoveInput(ctx context.Context, req *obsgrpc.RemoveInputRequest) (*obsgrpc.RemoveInputResponse, error) {
	return p.OBSClient.RemoveInput(ctx, req)
}
func (p *Proxy) SetInputName(ctx context.Context, req *obsgrpc.SetInputNameRequest) (_ret *obsgrpc.SetInputNameResponse, _err error) {
	logger.Debugf(ctx, "SetInputName")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/SetInputName: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &inputs.SetInputNameParams{}
	if req != nil {
		params = &inputs.SetInputNameParams{
			InputName:    req.InputName,
			InputUuid:    req.InputUUID,
			NewInputName: ptr(req.NewInputName),
		}
	}
	resp, err := client.Inputs.SetInputName(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.SetInputNameResponse{}
	return result, nil
}
func (p *ProxyAsClient) SetInputName(ctx context.Context, req *obsgrpc.SetInputNameRequest, opts ...grpc.CallOption) (*obsgrpc.SetInputNameResponse, error) {
	return (*Proxy)(p).SetInputName(ctx, req)
}
func (p *ClientAsServer) SetInputName(ctx context.Context, req *obsgrpc.SetInputNameRequest) (*obsgrpc.SetInputNameResponse, error) {
	return p.OBSClient.SetInputName(ctx, req)
}
func (p *Proxy) GetInputDefaultSettings(ctx context.Context, req *obsgrpc.GetInputDefaultSettingsRequest) (_ret *obsgrpc.GetInputDefaultSettingsResponse, _err error) {
	logger.Debugf(ctx, "GetInputDefaultSettings")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/GetInputDefaultSettings: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &inputs.GetInputDefaultSettingsParams{}
	if req != nil {
		params = &inputs.GetInputDefaultSettingsParams{
			InputKind: ptr(req.InputKind),
		}
	}
	resp, err := client.Inputs.GetInputDefaultSettings(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.GetInputDefaultSettingsResponse{
		DefaultInputSettings: toAbstractObject[map[string]any](resp.DefaultInputSettings),
	}
	return result, nil
}
func (p *ProxyAsClient) GetInputDefaultSettings(ctx context.Context, req *obsgrpc.GetInputDefaultSettingsRequest, opts ...grpc.CallOption) (*obsgrpc.GetInputDefaultSettingsResponse, error) {
	return (*Proxy)(p).GetInputDefaultSettings(ctx, req)
}
func (p *ClientAsServer) GetInputDefaultSettings(ctx context.Context, req *obsgrpc.GetInputDefaultSettingsRequest) (*obsgrpc.GetInputDefaultSettingsResponse, error) {
	return p.OBSClient.GetInputDefaultSettings(ctx, req)
}
func (p *Proxy) GetInputSettings(ctx context.Context, req *obsgrpc.GetInputSettingsRequest) (_ret *obsgrpc.GetInputSettingsResponse, _err error) {
	logger.Debugf(ctx, "GetInputSettings")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/GetInputSettings: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &inputs.GetInputSettingsParams{}
	if req != nil {
		params = &inputs.GetInputSettingsParams{
			InputName: req.InputName,
			InputUuid: req.InputUUID,
		}
	}
	resp, err := client.Inputs.GetInputSettings(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.GetInputSettingsResponse{
		InputSettings: toAbstractObject[map[string]any](resp.InputSettings),
		InputKind:     resp.InputKind,
	}
	return result, nil
}
func (p *ProxyAsClient) GetInputSettings(ctx context.Context, req *obsgrpc.GetInputSettingsRequest, opts ...grpc.CallOption) (*obsgrpc.GetInputSettingsResponse, error) {
	return (*Proxy)(p).GetInputSettings(ctx, req)
}
func (p *ClientAsServer) GetInputSettings(ctx context.Context, req *obsgrpc.GetInputSettingsRequest) (*obsgrpc.GetInputSettingsResponse, error) {
	return p.OBSClient.GetInputSettings(ctx, req)
}
func (p *Proxy) SetInputSettings(ctx context.Context, req *obsgrpc.SetInputSettingsRequest) (_ret *obsgrpc.SetInputSettingsResponse, _err error) {
	logger.Debugf(ctx, "SetInputSettings")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/SetInputSettings: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &inputs.SetInputSettingsParams{}
	if req != nil {
		params = &inputs.SetInputSettingsParams{
			InputName:     req.InputName,
			InputUuid:     req.InputUUID,
			InputSettings: fromAbstractObject[map[string]any](req.InputSettings),
			Overlay:       req.Overlay,
		}
	}
	resp, err := client.Inputs.SetInputSettings(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.SetInputSettingsResponse{}
	return result, nil
}
func (p *ProxyAsClient) SetInputSettings(ctx context.Context, req *obsgrpc.SetInputSettingsRequest, opts ...grpc.CallOption) (*obsgrpc.SetInputSettingsResponse, error) {
	return (*Proxy)(p).SetInputSettings(ctx, req)
}
func (p *ClientAsServer) SetInputSettings(ctx context.Context, req *obsgrpc.SetInputSettingsRequest) (*obsgrpc.SetInputSettingsResponse, error) {
	return p.OBSClient.SetInputSettings(ctx, req)
}
func (p *Proxy) GetInputMute(ctx context.Context, req *obsgrpc.GetInputMuteRequest) (_ret *obsgrpc.GetInputMuteResponse, _err error) {
	logger.Debugf(ctx, "GetInputMute")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/GetInputMute: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &inputs.GetInputMuteParams{}
	if req != nil {
		params = &inputs.GetInputMuteParams{
			InputName: req.InputName,
			InputUuid: req.InputUUID,
		}
	}
	resp, err := client.Inputs.GetInputMute(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.GetInputMuteResponse{
		InputMuted: resp.InputMuted,
	}
	return result, nil
}
func (p *ProxyAsClient) GetInputMute(ctx context.Context, req *obsgrpc.GetInputMuteRequest, opts ...grpc.CallOption) (*obsgrpc.GetInputMuteResponse, error) {
	return (*Proxy)(p).GetInputMute(ctx, req)
}
func (p *ClientAsServer) GetInputMute(ctx context.Context, req *obsgrpc.GetInputMuteRequest) (*obsgrpc.GetInputMuteResponse, error) {
	return p.OBSClient.GetInputMute(ctx, req)
}
func (p *Proxy) SetInputMute(ctx context.Context, req *obsgrpc.SetInputMuteRequest) (_ret *obsgrpc.SetInputMuteResponse, _err error) {
	logger.Debugf(ctx, "SetInputMute")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/SetInputMute: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &inputs.SetInputMuteParams{}
	if req != nil {
		params = &inputs.SetInputMuteParams{
			InputName:  req.InputName,
			InputUuid:  req.InputUUID,
			InputMuted: ptr(req.InputMuted),
		}
	}
	resp, err := client.Inputs.SetInputMute(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.SetInputMuteResponse{}
	return result, nil
}
func (p *ProxyAsClient) SetInputMute(ctx context.Context, req *obsgrpc.SetInputMuteRequest, opts ...grpc.CallOption) (*obsgrpc.SetInputMuteResponse, error) {
	return (*Proxy)(p).SetInputMute(ctx, req)
}
func (p *ClientAsServer) SetInputMute(ctx context.Context, req *obsgrpc.SetInputMuteRequest) (*obsgrpc.SetInputMuteResponse, error) {
	return p.OBSClient.SetInputMute(ctx, req)
}
func (p *Proxy) ToggleInputMute(ctx context.Context, req *obsgrpc.ToggleInputMuteRequest) (_ret *obsgrpc.ToggleInputMuteResponse, _err error) {
	logger.Debugf(ctx, "ToggleInputMute")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/ToggleInputMute: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &inputs.ToggleInputMuteParams{}
	if req != nil {
		params = &inputs.ToggleInputMuteParams{
			InputName: req.InputName,
			InputUuid: req.InputUUID,
		}
	}
	resp, err := client.Inputs.ToggleInputMute(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.ToggleInputMuteResponse{
		InputMuted: resp.InputMuted,
	}
	return result, nil
}
func (p *ProxyAsClient) ToggleInputMute(ctx context.Context, req *obsgrpc.ToggleInputMuteRequest, opts ...grpc.CallOption) (*obsgrpc.ToggleInputMuteResponse, error) {
	return (*Proxy)(p).ToggleInputMute(ctx, req)
}
func (p *ClientAsServer) ToggleInputMute(ctx context.Context, req *obsgrpc.ToggleInputMuteRequest) (*obsgrpc.ToggleInputMuteResponse, error) {
	return p.OBSClient.ToggleInputMute(ctx, req)
}
func (p *Proxy) GetInputVolume(ctx context.Context, req *obsgrpc.GetInputVolumeRequest) (_ret *obsgrpc.GetInputVolumeResponse, _err error) {
	logger.Debugf(ctx, "GetInputVolume")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/GetInputVolume: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &inputs.GetInputVolumeParams{}
	if req != nil {
		params = &inputs.GetInputVolumeParams{
			InputName: req.InputName,
			InputUuid: req.InputUUID,
		}
	}
	resp, err := client.Inputs.GetInputVolume(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.GetInputVolumeResponse{
		InputVolumeMul: (int64)(resp.InputVolumeMul),
		InputVolumeDb:  (int64)(resp.InputVolumeDb),
	}
	return result, nil
}
func (p *ProxyAsClient) GetInputVolume(ctx context.Context, req *obsgrpc.GetInputVolumeRequest, opts ...grpc.CallOption) (*obsgrpc.GetInputVolumeResponse, error) {
	return (*Proxy)(p).GetInputVolume(ctx, req)
}
func (p *ClientAsServer) GetInputVolume(ctx context.Context, req *obsgrpc.GetInputVolumeRequest) (*obsgrpc.GetInputVolumeResponse, error) {
	return p.OBSClient.GetInputVolume(ctx, req)
}
func (p *Proxy) SetInputVolume(ctx context.Context, req *obsgrpc.SetInputVolumeRequest) (_ret *obsgrpc.SetInputVolumeResponse, _err error) {
	logger.Debugf(ctx, "SetInputVolume")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/SetInputVolume: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &inputs.SetInputVolumeParams{}
	if req != nil {
		params = &inputs.SetInputVolumeParams{
			InputName:      req.InputName,
			InputUuid:      req.InputUUID,
			InputVolumeMul: ptrInt64ToFloat64(req.InputVolumeMul),
			InputVolumeDb:  ptrInt64ToFloat64(req.InputVolumeDb),
		}
	}
	resp, err := client.Inputs.SetInputVolume(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.SetInputVolumeResponse{}
	return result, nil
}
func (p *ProxyAsClient) SetInputVolume(ctx context.Context, req *obsgrpc.SetInputVolumeRequest, opts ...grpc.CallOption) (*obsgrpc.SetInputVolumeResponse, error) {
	return (*Proxy)(p).SetInputVolume(ctx, req)
}
func (p *ClientAsServer) SetInputVolume(ctx context.Context, req *obsgrpc.SetInputVolumeRequest) (*obsgrpc.SetInputVolumeResponse, error) {
	return p.OBSClient.SetInputVolume(ctx, req)
}
func (p *Proxy) GetInputAudioBalance(ctx context.Context, req *obsgrpc.GetInputAudioBalanceRequest) (_ret *obsgrpc.GetInputAudioBalanceResponse, _err error) {
	logger.Debugf(ctx, "GetInputAudioBalance")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/GetInputAudioBalance: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &inputs.GetInputAudioBalanceParams{}
	if req != nil {
		params = &inputs.GetInputAudioBalanceParams{
			InputName: req.InputName,
			InputUuid: req.InputUUID,
		}
	}
	resp, err := client.Inputs.GetInputAudioBalance(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.GetInputAudioBalanceResponse{
		InputAudioBalance: resp.InputAudioBalance,
	}
	return result, nil
}
func (p *ProxyAsClient) GetInputAudioBalance(ctx context.Context, req *obsgrpc.GetInputAudioBalanceRequest, opts ...grpc.CallOption) (*obsgrpc.GetInputAudioBalanceResponse, error) {
	return (*Proxy)(p).GetInputAudioBalance(ctx, req)
}
func (p *ClientAsServer) GetInputAudioBalance(ctx context.Context, req *obsgrpc.GetInputAudioBalanceRequest) (*obsgrpc.GetInputAudioBalanceResponse, error) {
	return p.OBSClient.GetInputAudioBalance(ctx, req)
}
func (p *Proxy) SetInputAudioBalance(ctx context.Context, req *obsgrpc.SetInputAudioBalanceRequest) (_ret *obsgrpc.SetInputAudioBalanceResponse, _err error) {
	logger.Debugf(ctx, "SetInputAudioBalance")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/SetInputAudioBalance: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &inputs.SetInputAudioBalanceParams{}
	if req != nil {
		params = &inputs.SetInputAudioBalanceParams{
			InputName:         req.InputName,
			InputUuid:         req.InputUUID,
			InputAudioBalance: ptr(req.InputAudioBalance),
		}
	}
	resp, err := client.Inputs.SetInputAudioBalance(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.SetInputAudioBalanceResponse{}
	return result, nil
}
func (p *ProxyAsClient) SetInputAudioBalance(ctx context.Context, req *obsgrpc.SetInputAudioBalanceRequest, opts ...grpc.CallOption) (*obsgrpc.SetInputAudioBalanceResponse, error) {
	return (*Proxy)(p).SetInputAudioBalance(ctx, req)
}
func (p *ClientAsServer) SetInputAudioBalance(ctx context.Context, req *obsgrpc.SetInputAudioBalanceRequest) (*obsgrpc.SetInputAudioBalanceResponse, error) {
	return p.OBSClient.SetInputAudioBalance(ctx, req)
}
func (p *Proxy) GetInputAudioSyncOffset(ctx context.Context, req *obsgrpc.GetInputAudioSyncOffsetRequest) (_ret *obsgrpc.GetInputAudioSyncOffsetResponse, _err error) {
	logger.Debugf(ctx, "GetInputAudioSyncOffset")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/GetInputAudioSyncOffset: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &inputs.GetInputAudioSyncOffsetParams{}
	if req != nil {
		params = &inputs.GetInputAudioSyncOffsetParams{
			InputName: req.InputName,
			InputUuid: req.InputUUID,
		}
	}
	resp, err := client.Inputs.GetInputAudioSyncOffset(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.GetInputAudioSyncOffsetResponse{
		InputAudioSyncOffset: (int64)(resp.InputAudioSyncOffset),
	}
	return result, nil
}
func (p *ProxyAsClient) GetInputAudioSyncOffset(ctx context.Context, req *obsgrpc.GetInputAudioSyncOffsetRequest, opts ...grpc.CallOption) (*obsgrpc.GetInputAudioSyncOffsetResponse, error) {
	return (*Proxy)(p).GetInputAudioSyncOffset(ctx, req)
}
func (p *ClientAsServer) GetInputAudioSyncOffset(ctx context.Context, req *obsgrpc.GetInputAudioSyncOffsetRequest) (*obsgrpc.GetInputAudioSyncOffsetResponse, error) {
	return p.OBSClient.GetInputAudioSyncOffset(ctx, req)
}
func (p *Proxy) SetInputAudioSyncOffset(ctx context.Context, req *obsgrpc.SetInputAudioSyncOffsetRequest) (_ret *obsgrpc.SetInputAudioSyncOffsetResponse, _err error) {
	logger.Debugf(ctx, "SetInputAudioSyncOffset")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/SetInputAudioSyncOffset: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &inputs.SetInputAudioSyncOffsetParams{}
	if req != nil {
		params = &inputs.SetInputAudioSyncOffsetParams{
			InputName:            req.InputName,
			InputUuid:            req.InputUUID,
			InputAudioSyncOffset: ptr((float64)(req.InputAudioSyncOffset)),
		}
	}
	resp, err := client.Inputs.SetInputAudioSyncOffset(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.SetInputAudioSyncOffsetResponse{}
	return result, nil
}
func (p *ProxyAsClient) SetInputAudioSyncOffset(ctx context.Context, req *obsgrpc.SetInputAudioSyncOffsetRequest, opts ...grpc.CallOption) (*obsgrpc.SetInputAudioSyncOffsetResponse, error) {
	return (*Proxy)(p).SetInputAudioSyncOffset(ctx, req)
}
func (p *ClientAsServer) SetInputAudioSyncOffset(ctx context.Context, req *obsgrpc.SetInputAudioSyncOffsetRequest) (*obsgrpc.SetInputAudioSyncOffsetResponse, error) {
	return p.OBSClient.SetInputAudioSyncOffset(ctx, req)
}
func (p *Proxy) GetInputAudioMonitorType(ctx context.Context, req *obsgrpc.GetInputAudioMonitorTypeRequest) (_ret *obsgrpc.GetInputAudioMonitorTypeResponse, _err error) {
	logger.Debugf(ctx, "GetInputAudioMonitorType")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/GetInputAudioMonitorType: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &inputs.GetInputAudioMonitorTypeParams{}
	if req != nil {
		params = &inputs.GetInputAudioMonitorTypeParams{
			InputName: req.InputName,
			InputUuid: req.InputUUID,
		}
	}
	resp, err := client.Inputs.GetInputAudioMonitorType(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.GetInputAudioMonitorTypeResponse{
		MonitorType: ([]byte)(resp.MonitorType),
	}
	return result, nil
}
func (p *ProxyAsClient) GetInputAudioMonitorType(ctx context.Context, req *obsgrpc.GetInputAudioMonitorTypeRequest, opts ...grpc.CallOption) (*obsgrpc.GetInputAudioMonitorTypeResponse, error) {
	return (*Proxy)(p).GetInputAudioMonitorType(ctx, req)
}
func (p *ClientAsServer) GetInputAudioMonitorType(ctx context.Context, req *obsgrpc.GetInputAudioMonitorTypeRequest) (*obsgrpc.GetInputAudioMonitorTypeResponse, error) {
	return p.OBSClient.GetInputAudioMonitorType(ctx, req)
}
func (p *Proxy) SetInputAudioMonitorType(ctx context.Context, req *obsgrpc.SetInputAudioMonitorTypeRequest) (_ret *obsgrpc.SetInputAudioMonitorTypeResponse, _err error) {
	logger.Debugf(ctx, "SetInputAudioMonitorType")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/SetInputAudioMonitorType: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &inputs.SetInputAudioMonitorTypeParams{}
	if req != nil {
		params = &inputs.SetInputAudioMonitorTypeParams{
			InputName:   req.InputName,
			InputUuid:   req.InputUUID,
			MonitorType: ptr((string)(req.MonitorType)),
		}
	}
	resp, err := client.Inputs.SetInputAudioMonitorType(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.SetInputAudioMonitorTypeResponse{}
	return result, nil
}
func (p *ProxyAsClient) SetInputAudioMonitorType(ctx context.Context, req *obsgrpc.SetInputAudioMonitorTypeRequest, opts ...grpc.CallOption) (*obsgrpc.SetInputAudioMonitorTypeResponse, error) {
	return (*Proxy)(p).SetInputAudioMonitorType(ctx, req)
}
func (p *ClientAsServer) SetInputAudioMonitorType(ctx context.Context, req *obsgrpc.SetInputAudioMonitorTypeRequest) (*obsgrpc.SetInputAudioMonitorTypeResponse, error) {
	return p.OBSClient.SetInputAudioMonitorType(ctx, req)
}
func (p *Proxy) GetInputAudioTracks(ctx context.Context, req *obsgrpc.GetInputAudioTracksRequest) (_ret *obsgrpc.GetInputAudioTracksResponse, _err error) {
	logger.Debugf(ctx, "GetInputAudioTracks")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/GetInputAudioTracks: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &inputs.GetInputAudioTracksParams{}
	if req != nil {
		params = &inputs.GetInputAudioTracksParams{
			InputName: req.InputName,
			InputUuid: req.InputUUID,
		}
	}
	resp, err := client.Inputs.GetInputAudioTracks(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.GetInputAudioTracksResponse{
		InputAudioTracks: toAbstractObject[*typedefs.InputAudioTracks](resp.InputAudioTracks),
	}
	return result, nil
}
func (p *ProxyAsClient) GetInputAudioTracks(ctx context.Context, req *obsgrpc.GetInputAudioTracksRequest, opts ...grpc.CallOption) (*obsgrpc.GetInputAudioTracksResponse, error) {
	return (*Proxy)(p).GetInputAudioTracks(ctx, req)
}
func (p *ClientAsServer) GetInputAudioTracks(ctx context.Context, req *obsgrpc.GetInputAudioTracksRequest) (*obsgrpc.GetInputAudioTracksResponse, error) {
	return p.OBSClient.GetInputAudioTracks(ctx, req)
}
func (p *Proxy) SetInputAudioTracks(ctx context.Context, req *obsgrpc.SetInputAudioTracksRequest) (_ret *obsgrpc.SetInputAudioTracksResponse, _err error) {
	logger.Debugf(ctx, "SetInputAudioTracks")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/SetInputAudioTracks: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &inputs.SetInputAudioTracksParams{}
	if req != nil {
		params = &inputs.SetInputAudioTracksParams{
			InputName:        req.InputName,
			InputUuid:        req.InputUUID,
			InputAudioTracks: fromAbstractObject[*typedefs.InputAudioTracks](req.InputAudioTracks),
		}
	}
	resp, err := client.Inputs.SetInputAudioTracks(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.SetInputAudioTracksResponse{}
	return result, nil
}
func (p *ProxyAsClient) SetInputAudioTracks(ctx context.Context, req *obsgrpc.SetInputAudioTracksRequest, opts ...grpc.CallOption) (*obsgrpc.SetInputAudioTracksResponse, error) {
	return (*Proxy)(p).SetInputAudioTracks(ctx, req)
}
func (p *ClientAsServer) SetInputAudioTracks(ctx context.Context, req *obsgrpc.SetInputAudioTracksRequest) (*obsgrpc.SetInputAudioTracksResponse, error) {
	return p.OBSClient.SetInputAudioTracks(ctx, req)
}
func (p *Proxy) GetInputPropertiesListPropertyItems(ctx context.Context, req *obsgrpc.GetInputPropertiesListPropertyItemsRequest) (_ret *obsgrpc.GetInputPropertiesListPropertyItemsResponse, _err error) {
	logger.Debugf(ctx, "GetInputPropertiesListPropertyItems")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/GetInputPropertiesListPropertyItems: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &inputs.GetInputPropertiesListPropertyItemsParams{}
	if req != nil {
		params = &inputs.GetInputPropertiesListPropertyItemsParams{
			InputName:    req.InputName,
			InputUuid:    req.InputUUID,
			PropertyName: ptr(req.PropertyName),
		}
	}
	resp, err := client.Inputs.GetInputPropertiesListPropertyItems(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.GetInputPropertiesListPropertyItemsResponse{
		PropertyItems: toAbstractObjects[*typedefs.PropertyItem](resp.PropertyItems),
	}
	return result, nil
}
func (p *ProxyAsClient) GetInputPropertiesListPropertyItems(ctx context.Context, req *obsgrpc.GetInputPropertiesListPropertyItemsRequest, opts ...grpc.CallOption) (*obsgrpc.GetInputPropertiesListPropertyItemsResponse, error) {
	return (*Proxy)(p).GetInputPropertiesListPropertyItems(ctx, req)
}
func (p *ClientAsServer) GetInputPropertiesListPropertyItems(ctx context.Context, req *obsgrpc.GetInputPropertiesListPropertyItemsRequest) (*obsgrpc.GetInputPropertiesListPropertyItemsResponse, error) {
	return p.OBSClient.GetInputPropertiesListPropertyItems(ctx, req)
}
func (p *Proxy) PressInputPropertiesButton(ctx context.Context, req *obsgrpc.PressInputPropertiesButtonRequest) (_ret *obsgrpc.PressInputPropertiesButtonResponse, _err error) {
	logger.Debugf(ctx, "PressInputPropertiesButton")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/PressInputPropertiesButton: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &inputs.PressInputPropertiesButtonParams{}
	if req != nil {
		params = &inputs.PressInputPropertiesButtonParams{
			InputName:    req.InputName,
			InputUuid:    req.InputUUID,
			PropertyName: ptr(req.PropertyName),
		}
	}
	resp, err := client.Inputs.PressInputPropertiesButton(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.PressInputPropertiesButtonResponse{}
	return result, nil
}
func (p *ProxyAsClient) PressInputPropertiesButton(ctx context.Context, req *obsgrpc.PressInputPropertiesButtonRequest, opts ...grpc.CallOption) (*obsgrpc.PressInputPropertiesButtonResponse, error) {
	return (*Proxy)(p).PressInputPropertiesButton(ctx, req)
}
func (p *ClientAsServer) PressInputPropertiesButton(ctx context.Context, req *obsgrpc.PressInputPropertiesButtonRequest) (*obsgrpc.PressInputPropertiesButtonResponse, error) {
	return p.OBSClient.PressInputPropertiesButton(ctx, req)
}
func (p *Proxy) GetMediaInputStatus(ctx context.Context, req *obsgrpc.GetMediaInputStatusRequest) (_ret *obsgrpc.GetMediaInputStatusResponse, _err error) {
	logger.Debugf(ctx, "GetMediaInputStatus")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/GetMediaInputStatus: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &mediainputs.GetMediaInputStatusParams{}
	if req != nil {
		params = &mediainputs.GetMediaInputStatusParams{
			InputName: req.InputName,
			InputUuid: req.InputUUID,
		}
	}
	resp, err := client.MediaInputs.GetMediaInputStatus(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.GetMediaInputStatusResponse{
		MediaState:    ([]byte)(resp.MediaState),
		MediaDuration: (int64)(resp.MediaDuration),
		MediaCursor:   (int64)(resp.MediaCursor),
	}
	return result, nil
}
func (p *ProxyAsClient) GetMediaInputStatus(ctx context.Context, req *obsgrpc.GetMediaInputStatusRequest, opts ...grpc.CallOption) (*obsgrpc.GetMediaInputStatusResponse, error) {
	return (*Proxy)(p).GetMediaInputStatus(ctx, req)
}
func (p *ClientAsServer) GetMediaInputStatus(ctx context.Context, req *obsgrpc.GetMediaInputStatusRequest) (*obsgrpc.GetMediaInputStatusResponse, error) {
	return p.OBSClient.GetMediaInputStatus(ctx, req)
}
func (p *Proxy) SetMediaInputCursor(ctx context.Context, req *obsgrpc.SetMediaInputCursorRequest) (_ret *obsgrpc.SetMediaInputCursorResponse, _err error) {
	logger.Debugf(ctx, "SetMediaInputCursor")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/SetMediaInputCursor: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &mediainputs.SetMediaInputCursorParams{}
	if req != nil {
		params = &mediainputs.SetMediaInputCursorParams{
			InputName:   req.InputName,
			InputUuid:   req.InputUUID,
			MediaCursor: ptr((float64)(req.MediaCursor)),
		}
	}
	resp, err := client.MediaInputs.SetMediaInputCursor(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.SetMediaInputCursorResponse{}
	return result, nil
}
func (p *ProxyAsClient) SetMediaInputCursor(ctx context.Context, req *obsgrpc.SetMediaInputCursorRequest, opts ...grpc.CallOption) (*obsgrpc.SetMediaInputCursorResponse, error) {
	return (*Proxy)(p).SetMediaInputCursor(ctx, req)
}
func (p *ClientAsServer) SetMediaInputCursor(ctx context.Context, req *obsgrpc.SetMediaInputCursorRequest) (*obsgrpc.SetMediaInputCursorResponse, error) {
	return p.OBSClient.SetMediaInputCursor(ctx, req)
}
func (p *Proxy) OffsetMediaInputCursor(ctx context.Context, req *obsgrpc.OffsetMediaInputCursorRequest) (_ret *obsgrpc.OffsetMediaInputCursorResponse, _err error) {
	logger.Debugf(ctx, "OffsetMediaInputCursor")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/OffsetMediaInputCursor: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &mediainputs.OffsetMediaInputCursorParams{}
	if req != nil {
		params = &mediainputs.OffsetMediaInputCursorParams{
			InputName:         req.InputName,
			InputUuid:         req.InputUUID,
			MediaCursorOffset: ptr((float64)(req.MediaCursorOffset)),
		}
	}
	resp, err := client.MediaInputs.OffsetMediaInputCursor(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.OffsetMediaInputCursorResponse{}
	return result, nil
}
func (p *ProxyAsClient) OffsetMediaInputCursor(ctx context.Context, req *obsgrpc.OffsetMediaInputCursorRequest, opts ...grpc.CallOption) (*obsgrpc.OffsetMediaInputCursorResponse, error) {
	return (*Proxy)(p).OffsetMediaInputCursor(ctx, req)
}
func (p *ClientAsServer) OffsetMediaInputCursor(ctx context.Context, req *obsgrpc.OffsetMediaInputCursorRequest) (*obsgrpc.OffsetMediaInputCursorResponse, error) {
	return p.OBSClient.OffsetMediaInputCursor(ctx, req)
}
func (p *Proxy) TriggerMediaInputAction(ctx context.Context, req *obsgrpc.TriggerMediaInputActionRequest) (_ret *obsgrpc.TriggerMediaInputActionResponse, _err error) {
	logger.Debugf(ctx, "TriggerMediaInputAction")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/TriggerMediaInputAction: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &mediainputs.TriggerMediaInputActionParams{}
	if req != nil {
		params = &mediainputs.TriggerMediaInputActionParams{
			InputName:   req.InputName,
			InputUuid:   req.InputUUID,
			MediaAction: ptr(req.MediaAction),
		}
	}
	resp, err := client.MediaInputs.TriggerMediaInputAction(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.TriggerMediaInputActionResponse{}
	return result, nil
}
func (p *ProxyAsClient) TriggerMediaInputAction(ctx context.Context, req *obsgrpc.TriggerMediaInputActionRequest, opts ...grpc.CallOption) (*obsgrpc.TriggerMediaInputActionResponse, error) {
	return (*Proxy)(p).TriggerMediaInputAction(ctx, req)
}
func (p *ClientAsServer) TriggerMediaInputAction(ctx context.Context, req *obsgrpc.TriggerMediaInputActionRequest) (*obsgrpc.TriggerMediaInputActionResponse, error) {
	return p.OBSClient.TriggerMediaInputAction(ctx, req)
}
func (p *Proxy) GetVirtualCamStatus(ctx context.Context, req *obsgrpc.GetVirtualCamStatusRequest) (_ret *obsgrpc.GetVirtualCamStatusResponse, _err error) {
	logger.Debugf(ctx, "GetVirtualCamStatus")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/GetVirtualCamStatus: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &outputs.GetVirtualCamStatusParams{}
	if req != nil {
		params = &outputs.GetVirtualCamStatusParams{}
	}
	resp, err := client.Outputs.GetVirtualCamStatus(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.GetVirtualCamStatusResponse{
		OutputActive: resp.OutputActive,
	}
	return result, nil
}
func (p *ProxyAsClient) GetVirtualCamStatus(ctx context.Context, req *obsgrpc.GetVirtualCamStatusRequest, opts ...grpc.CallOption) (*obsgrpc.GetVirtualCamStatusResponse, error) {
	return (*Proxy)(p).GetVirtualCamStatus(ctx, req)
}
func (p *ClientAsServer) GetVirtualCamStatus(ctx context.Context, req *obsgrpc.GetVirtualCamStatusRequest) (*obsgrpc.GetVirtualCamStatusResponse, error) {
	return p.OBSClient.GetVirtualCamStatus(ctx, req)
}
func (p *Proxy) ToggleVirtualCam(ctx context.Context, req *obsgrpc.ToggleVirtualCamRequest) (_ret *obsgrpc.ToggleVirtualCamResponse, _err error) {
	logger.Debugf(ctx, "ToggleVirtualCam")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/ToggleVirtualCam: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &outputs.ToggleVirtualCamParams{}
	if req != nil {
		params = &outputs.ToggleVirtualCamParams{}
	}
	resp, err := client.Outputs.ToggleVirtualCam(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.ToggleVirtualCamResponse{
		OutputActive: resp.OutputActive,
	}
	return result, nil
}
func (p *ProxyAsClient) ToggleVirtualCam(ctx context.Context, req *obsgrpc.ToggleVirtualCamRequest, opts ...grpc.CallOption) (*obsgrpc.ToggleVirtualCamResponse, error) {
	return (*Proxy)(p).ToggleVirtualCam(ctx, req)
}
func (p *ClientAsServer) ToggleVirtualCam(ctx context.Context, req *obsgrpc.ToggleVirtualCamRequest) (*obsgrpc.ToggleVirtualCamResponse, error) {
	return p.OBSClient.ToggleVirtualCam(ctx, req)
}
func (p *Proxy) StartVirtualCam(ctx context.Context, req *obsgrpc.StartVirtualCamRequest) (_ret *obsgrpc.StartVirtualCamResponse, _err error) {
	logger.Debugf(ctx, "StartVirtualCam")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/StartVirtualCam: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &outputs.StartVirtualCamParams{}
	if req != nil {
		params = &outputs.StartVirtualCamParams{}
	}
	resp, err := client.Outputs.StartVirtualCam(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.StartVirtualCamResponse{}
	return result, nil
}
func (p *ProxyAsClient) StartVirtualCam(ctx context.Context, req *obsgrpc.StartVirtualCamRequest, opts ...grpc.CallOption) (*obsgrpc.StartVirtualCamResponse, error) {
	return (*Proxy)(p).StartVirtualCam(ctx, req)
}
func (p *ClientAsServer) StartVirtualCam(ctx context.Context, req *obsgrpc.StartVirtualCamRequest) (*obsgrpc.StartVirtualCamResponse, error) {
	return p.OBSClient.StartVirtualCam(ctx, req)
}
func (p *Proxy) StopVirtualCam(ctx context.Context, req *obsgrpc.StopVirtualCamRequest) (_ret *obsgrpc.StopVirtualCamResponse, _err error) {
	logger.Debugf(ctx, "StopVirtualCam")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/StopVirtualCam: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &outputs.StopVirtualCamParams{}
	if req != nil {
		params = &outputs.StopVirtualCamParams{}
	}
	resp, err := client.Outputs.StopVirtualCam(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.StopVirtualCamResponse{}
	return result, nil
}
func (p *ProxyAsClient) StopVirtualCam(ctx context.Context, req *obsgrpc.StopVirtualCamRequest, opts ...grpc.CallOption) (*obsgrpc.StopVirtualCamResponse, error) {
	return (*Proxy)(p).StopVirtualCam(ctx, req)
}
func (p *ClientAsServer) StopVirtualCam(ctx context.Context, req *obsgrpc.StopVirtualCamRequest) (*obsgrpc.StopVirtualCamResponse, error) {
	return p.OBSClient.StopVirtualCam(ctx, req)
}
func (p *Proxy) GetReplayBufferStatus(ctx context.Context, req *obsgrpc.GetReplayBufferStatusRequest) (_ret *obsgrpc.GetReplayBufferStatusResponse, _err error) {
	logger.Debugf(ctx, "GetReplayBufferStatus")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/GetReplayBufferStatus: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &outputs.GetReplayBufferStatusParams{}
	if req != nil {
		params = &outputs.GetReplayBufferStatusParams{}
	}
	resp, err := client.Outputs.GetReplayBufferStatus(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.GetReplayBufferStatusResponse{
		OutputActive: resp.OutputActive,
	}
	return result, nil
}
func (p *ProxyAsClient) GetReplayBufferStatus(ctx context.Context, req *obsgrpc.GetReplayBufferStatusRequest, opts ...grpc.CallOption) (*obsgrpc.GetReplayBufferStatusResponse, error) {
	return (*Proxy)(p).GetReplayBufferStatus(ctx, req)
}
func (p *ClientAsServer) GetReplayBufferStatus(ctx context.Context, req *obsgrpc.GetReplayBufferStatusRequest) (*obsgrpc.GetReplayBufferStatusResponse, error) {
	return p.OBSClient.GetReplayBufferStatus(ctx, req)
}
func (p *Proxy) ToggleReplayBuffer(ctx context.Context, req *obsgrpc.ToggleReplayBufferRequest) (_ret *obsgrpc.ToggleReplayBufferResponse, _err error) {
	logger.Debugf(ctx, "ToggleReplayBuffer")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/ToggleReplayBuffer: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &outputs.ToggleReplayBufferParams{}
	if req != nil {
		params = &outputs.ToggleReplayBufferParams{}
	}
	resp, err := client.Outputs.ToggleReplayBuffer(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.ToggleReplayBufferResponse{
		OutputActive: resp.OutputActive,
	}
	return result, nil
}
func (p *ProxyAsClient) ToggleReplayBuffer(ctx context.Context, req *obsgrpc.ToggleReplayBufferRequest, opts ...grpc.CallOption) (*obsgrpc.ToggleReplayBufferResponse, error) {
	return (*Proxy)(p).ToggleReplayBuffer(ctx, req)
}
func (p *ClientAsServer) ToggleReplayBuffer(ctx context.Context, req *obsgrpc.ToggleReplayBufferRequest) (*obsgrpc.ToggleReplayBufferResponse, error) {
	return p.OBSClient.ToggleReplayBuffer(ctx, req)
}
func (p *Proxy) StartReplayBuffer(ctx context.Context, req *obsgrpc.StartReplayBufferRequest) (_ret *obsgrpc.StartReplayBufferResponse, _err error) {
	logger.Debugf(ctx, "StartReplayBuffer")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/StartReplayBuffer: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &outputs.StartReplayBufferParams{}
	if req != nil {
		params = &outputs.StartReplayBufferParams{}
	}
	resp, err := client.Outputs.StartReplayBuffer(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.StartReplayBufferResponse{}
	return result, nil
}
func (p *ProxyAsClient) StartReplayBuffer(ctx context.Context, req *obsgrpc.StartReplayBufferRequest, opts ...grpc.CallOption) (*obsgrpc.StartReplayBufferResponse, error) {
	return (*Proxy)(p).StartReplayBuffer(ctx, req)
}
func (p *ClientAsServer) StartReplayBuffer(ctx context.Context, req *obsgrpc.StartReplayBufferRequest) (*obsgrpc.StartReplayBufferResponse, error) {
	return p.OBSClient.StartReplayBuffer(ctx, req)
}
func (p *Proxy) StopReplayBuffer(ctx context.Context, req *obsgrpc.StopReplayBufferRequest) (_ret *obsgrpc.StopReplayBufferResponse, _err error) {
	logger.Debugf(ctx, "StopReplayBuffer")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/StopReplayBuffer: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &outputs.StopReplayBufferParams{}
	if req != nil {
		params = &outputs.StopReplayBufferParams{}
	}
	resp, err := client.Outputs.StopReplayBuffer(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.StopReplayBufferResponse{}
	return result, nil
}
func (p *ProxyAsClient) StopReplayBuffer(ctx context.Context, req *obsgrpc.StopReplayBufferRequest, opts ...grpc.CallOption) (*obsgrpc.StopReplayBufferResponse, error) {
	return (*Proxy)(p).StopReplayBuffer(ctx, req)
}
func (p *ClientAsServer) StopReplayBuffer(ctx context.Context, req *obsgrpc.StopReplayBufferRequest) (*obsgrpc.StopReplayBufferResponse, error) {
	return p.OBSClient.StopReplayBuffer(ctx, req)
}
func (p *Proxy) SaveReplayBuffer(ctx context.Context, req *obsgrpc.SaveReplayBufferRequest) (_ret *obsgrpc.SaveReplayBufferResponse, _err error) {
	logger.Debugf(ctx, "SaveReplayBuffer")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/SaveReplayBuffer: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &outputs.SaveReplayBufferParams{}
	if req != nil {
		params = &outputs.SaveReplayBufferParams{}
	}
	resp, err := client.Outputs.SaveReplayBuffer(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.SaveReplayBufferResponse{}
	return result, nil
}
func (p *ProxyAsClient) SaveReplayBuffer(ctx context.Context, req *obsgrpc.SaveReplayBufferRequest, opts ...grpc.CallOption) (*obsgrpc.SaveReplayBufferResponse, error) {
	return (*Proxy)(p).SaveReplayBuffer(ctx, req)
}
func (p *ClientAsServer) SaveReplayBuffer(ctx context.Context, req *obsgrpc.SaveReplayBufferRequest) (*obsgrpc.SaveReplayBufferResponse, error) {
	return p.OBSClient.SaveReplayBuffer(ctx, req)
}
func (p *Proxy) GetLastReplayBufferReplay(ctx context.Context, req *obsgrpc.GetLastReplayBufferReplayRequest) (_ret *obsgrpc.GetLastReplayBufferReplayResponse, _err error) {
	logger.Debugf(ctx, "GetLastReplayBufferReplay")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/GetLastReplayBufferReplay: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &outputs.GetLastReplayBufferReplayParams{}
	if req != nil {
		params = &outputs.GetLastReplayBufferReplayParams{}
	}
	resp, err := client.Outputs.GetLastReplayBufferReplay(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.GetLastReplayBufferReplayResponse{
		SavedReplayPath: resp.SavedReplayPath,
	}
	return result, nil
}
func (p *ProxyAsClient) GetLastReplayBufferReplay(ctx context.Context, req *obsgrpc.GetLastReplayBufferReplayRequest, opts ...grpc.CallOption) (*obsgrpc.GetLastReplayBufferReplayResponse, error) {
	return (*Proxy)(p).GetLastReplayBufferReplay(ctx, req)
}
func (p *ClientAsServer) GetLastReplayBufferReplay(ctx context.Context, req *obsgrpc.GetLastReplayBufferReplayRequest) (*obsgrpc.GetLastReplayBufferReplayResponse, error) {
	return p.OBSClient.GetLastReplayBufferReplay(ctx, req)
}
func (p *Proxy) GetOutputList(ctx context.Context, req *obsgrpc.GetOutputListRequest) (_ret *obsgrpc.GetOutputListResponse, _err error) {
	logger.Debugf(ctx, "GetOutputList")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/GetOutputList: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &outputs.GetOutputListParams{}
	if req != nil {
		params = &outputs.GetOutputListParams{}
	}
	resp, err := client.Outputs.GetOutputList(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.GetOutputListResponse{
		Outputs: toAbstractObjects[*typedefs.Output](resp.Outputs),
	}
	return result, nil
}
func (p *ProxyAsClient) GetOutputList(ctx context.Context, req *obsgrpc.GetOutputListRequest, opts ...grpc.CallOption) (*obsgrpc.GetOutputListResponse, error) {
	return (*Proxy)(p).GetOutputList(ctx, req)
}
func (p *ClientAsServer) GetOutputList(ctx context.Context, req *obsgrpc.GetOutputListRequest) (*obsgrpc.GetOutputListResponse, error) {
	return p.OBSClient.GetOutputList(ctx, req)
}
func (p *Proxy) GetOutputStatus(ctx context.Context, req *obsgrpc.GetOutputStatusRequest) (_ret *obsgrpc.GetOutputStatusResponse, _err error) {
	logger.Debugf(ctx, "GetOutputStatus")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/GetOutputStatus: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &outputs.GetOutputStatusParams{}
	if req != nil {
		params = &outputs.GetOutputStatusParams{
			OutputName: ptr(req.OutputName),
		}
	}
	resp, err := client.Outputs.GetOutputStatus(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.GetOutputStatusResponse{
		OutputActive:        resp.OutputActive,
		OutputReconnecting:  resp.OutputReconnecting,
		OutputTimecode:      ([]byte)(resp.OutputTimecode),
		OutputDuration:      (int64)(resp.OutputDuration),
		OutputCongestion:    (int64)(resp.OutputCongestion),
		OutputBytes:         (int64)(resp.OutputBytes),
		OutputSkippedFrames: (int64)(resp.OutputSkippedFrames),
		OutputTotalFrames:   (int64)(resp.OutputTotalFrames),
	}
	return result, nil
}
func (p *ProxyAsClient) GetOutputStatus(ctx context.Context, req *obsgrpc.GetOutputStatusRequest, opts ...grpc.CallOption) (*obsgrpc.GetOutputStatusResponse, error) {
	return (*Proxy)(p).GetOutputStatus(ctx, req)
}
func (p *ClientAsServer) GetOutputStatus(ctx context.Context, req *obsgrpc.GetOutputStatusRequest) (*obsgrpc.GetOutputStatusResponse, error) {
	return p.OBSClient.GetOutputStatus(ctx, req)
}
func (p *Proxy) ToggleOutput(ctx context.Context, req *obsgrpc.ToggleOutputRequest) (_ret *obsgrpc.ToggleOutputResponse, _err error) {
	logger.Debugf(ctx, "ToggleOutput")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/ToggleOutput: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &outputs.ToggleOutputParams{}
	if req != nil {
		params = &outputs.ToggleOutputParams{
			OutputName: ptr(req.OutputName),
		}
	}
	resp, err := client.Outputs.ToggleOutput(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.ToggleOutputResponse{
		OutputActive: resp.OutputActive,
	}
	return result, nil
}
func (p *ProxyAsClient) ToggleOutput(ctx context.Context, req *obsgrpc.ToggleOutputRequest, opts ...grpc.CallOption) (*obsgrpc.ToggleOutputResponse, error) {
	return (*Proxy)(p).ToggleOutput(ctx, req)
}
func (p *ClientAsServer) ToggleOutput(ctx context.Context, req *obsgrpc.ToggleOutputRequest) (*obsgrpc.ToggleOutputResponse, error) {
	return p.OBSClient.ToggleOutput(ctx, req)
}
func (p *Proxy) StartOutput(ctx context.Context, req *obsgrpc.StartOutputRequest) (_ret *obsgrpc.StartOutputResponse, _err error) {
	logger.Debugf(ctx, "StartOutput")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/StartOutput: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &outputs.StartOutputParams{}
	if req != nil {
		params = &outputs.StartOutputParams{
			OutputName: ptr(req.OutputName),
		}
	}
	resp, err := client.Outputs.StartOutput(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.StartOutputResponse{}
	return result, nil
}
func (p *ProxyAsClient) StartOutput(ctx context.Context, req *obsgrpc.StartOutputRequest, opts ...grpc.CallOption) (*obsgrpc.StartOutputResponse, error) {
	return (*Proxy)(p).StartOutput(ctx, req)
}
func (p *ClientAsServer) StartOutput(ctx context.Context, req *obsgrpc.StartOutputRequest) (*obsgrpc.StartOutputResponse, error) {
	return p.OBSClient.StartOutput(ctx, req)
}
func (p *Proxy) StopOutput(ctx context.Context, req *obsgrpc.StopOutputRequest) (_ret *obsgrpc.StopOutputResponse, _err error) {
	logger.Debugf(ctx, "StopOutput")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/StopOutput: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &outputs.StopOutputParams{}
	if req != nil {
		params = &outputs.StopOutputParams{
			OutputName: ptr(req.OutputName),
		}
	}
	resp, err := client.Outputs.StopOutput(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.StopOutputResponse{}
	return result, nil
}
func (p *ProxyAsClient) StopOutput(ctx context.Context, req *obsgrpc.StopOutputRequest, opts ...grpc.CallOption) (*obsgrpc.StopOutputResponse, error) {
	return (*Proxy)(p).StopOutput(ctx, req)
}
func (p *ClientAsServer) StopOutput(ctx context.Context, req *obsgrpc.StopOutputRequest) (*obsgrpc.StopOutputResponse, error) {
	return p.OBSClient.StopOutput(ctx, req)
}
func (p *Proxy) GetOutputSettings(ctx context.Context, req *obsgrpc.GetOutputSettingsRequest) (_ret *obsgrpc.GetOutputSettingsResponse, _err error) {
	logger.Debugf(ctx, "GetOutputSettings")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/GetOutputSettings: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &outputs.GetOutputSettingsParams{}
	if req != nil {
		params = &outputs.GetOutputSettingsParams{
			OutputName: ptr(req.OutputName),
		}
	}
	resp, err := client.Outputs.GetOutputSettings(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.GetOutputSettingsResponse{
		OutputSettings: toAbstractObject[map[string]any](resp.OutputSettings),
	}
	return result, nil
}
func (p *ProxyAsClient) GetOutputSettings(ctx context.Context, req *obsgrpc.GetOutputSettingsRequest, opts ...grpc.CallOption) (*obsgrpc.GetOutputSettingsResponse, error) {
	return (*Proxy)(p).GetOutputSettings(ctx, req)
}
func (p *ClientAsServer) GetOutputSettings(ctx context.Context, req *obsgrpc.GetOutputSettingsRequest) (*obsgrpc.GetOutputSettingsResponse, error) {
	return p.OBSClient.GetOutputSettings(ctx, req)
}
func (p *Proxy) SetOutputSettings(ctx context.Context, req *obsgrpc.SetOutputSettingsRequest) (_ret *obsgrpc.SetOutputSettingsResponse, _err error) {
	logger.Debugf(ctx, "SetOutputSettings")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/SetOutputSettings: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &outputs.SetOutputSettingsParams{}
	if req != nil {
		params = &outputs.SetOutputSettingsParams{
			OutputName:     ptr(req.OutputName),
			OutputSettings: fromAbstractObject[map[string]any](req.OutputSettings),
		}
	}
	resp, err := client.Outputs.SetOutputSettings(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.SetOutputSettingsResponse{}
	return result, nil
}
func (p *ProxyAsClient) SetOutputSettings(ctx context.Context, req *obsgrpc.SetOutputSettingsRequest, opts ...grpc.CallOption) (*obsgrpc.SetOutputSettingsResponse, error) {
	return (*Proxy)(p).SetOutputSettings(ctx, req)
}
func (p *ClientAsServer) SetOutputSettings(ctx context.Context, req *obsgrpc.SetOutputSettingsRequest) (*obsgrpc.SetOutputSettingsResponse, error) {
	return p.OBSClient.SetOutputSettings(ctx, req)
}
func (p *Proxy) GetRecordStatus(ctx context.Context, req *obsgrpc.GetRecordStatusRequest) (_ret *obsgrpc.GetRecordStatusResponse, _err error) {
	logger.Debugf(ctx, "GetRecordStatus")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/GetRecordStatus: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &record.GetRecordStatusParams{}
	if req != nil {
		params = &record.GetRecordStatusParams{}
	}
	resp, err := client.Record.GetRecordStatus(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.GetRecordStatusResponse{
		OutputActive:   resp.OutputActive,
		OutputPaused:   resp.OutputPaused,
		OutputTimecode: ([]byte)(resp.OutputTimecode),
		OutputDuration: (int64)(resp.OutputDuration),
		OutputBytes:    (int64)(resp.OutputBytes),
	}
	return result, nil
}
func (p *ProxyAsClient) GetRecordStatus(ctx context.Context, req *obsgrpc.GetRecordStatusRequest, opts ...grpc.CallOption) (*obsgrpc.GetRecordStatusResponse, error) {
	return (*Proxy)(p).GetRecordStatus(ctx, req)
}
func (p *ClientAsServer) GetRecordStatus(ctx context.Context, req *obsgrpc.GetRecordStatusRequest) (*obsgrpc.GetRecordStatusResponse, error) {
	return p.OBSClient.GetRecordStatus(ctx, req)
}
func (p *Proxy) ToggleRecord(ctx context.Context, req *obsgrpc.ToggleRecordRequest) (_ret *obsgrpc.ToggleRecordResponse, _err error) {
	logger.Debugf(ctx, "ToggleRecord")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/ToggleRecord: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &record.ToggleRecordParams{}
	if req != nil {
		params = &record.ToggleRecordParams{}
	}
	resp, err := client.Record.ToggleRecord(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.ToggleRecordResponse{
		OutputActive: resp.OutputActive,
	}
	return result, nil
}
func (p *ProxyAsClient) ToggleRecord(ctx context.Context, req *obsgrpc.ToggleRecordRequest, opts ...grpc.CallOption) (*obsgrpc.ToggleRecordResponse, error) {
	return (*Proxy)(p).ToggleRecord(ctx, req)
}
func (p *ClientAsServer) ToggleRecord(ctx context.Context, req *obsgrpc.ToggleRecordRequest) (*obsgrpc.ToggleRecordResponse, error) {
	return p.OBSClient.ToggleRecord(ctx, req)
}
func (p *Proxy) StartRecord(ctx context.Context, req *obsgrpc.StartRecordRequest) (_ret *obsgrpc.StartRecordResponse, _err error) {
	logger.Debugf(ctx, "StartRecord")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/StartRecord: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &record.StartRecordParams{}
	if req != nil {
		params = &record.StartRecordParams{}
	}
	resp, err := client.Record.StartRecord(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.StartRecordResponse{}
	return result, nil
}
func (p *ProxyAsClient) StartRecord(ctx context.Context, req *obsgrpc.StartRecordRequest, opts ...grpc.CallOption) (*obsgrpc.StartRecordResponse, error) {
	return (*Proxy)(p).StartRecord(ctx, req)
}
func (p *ClientAsServer) StartRecord(ctx context.Context, req *obsgrpc.StartRecordRequest) (*obsgrpc.StartRecordResponse, error) {
	return p.OBSClient.StartRecord(ctx, req)
}
func (p *Proxy) StopRecord(ctx context.Context, req *obsgrpc.StopRecordRequest) (_ret *obsgrpc.StopRecordResponse, _err error) {
	logger.Debugf(ctx, "StopRecord")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/StopRecord: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &record.StopRecordParams{}
	if req != nil {
		params = &record.StopRecordParams{}
	}
	resp, err := client.Record.StopRecord(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.StopRecordResponse{
		OutputPath: resp.OutputPath,
	}
	return result, nil
}
func (p *ProxyAsClient) StopRecord(ctx context.Context, req *obsgrpc.StopRecordRequest, opts ...grpc.CallOption) (*obsgrpc.StopRecordResponse, error) {
	return (*Proxy)(p).StopRecord(ctx, req)
}
func (p *ClientAsServer) StopRecord(ctx context.Context, req *obsgrpc.StopRecordRequest) (*obsgrpc.StopRecordResponse, error) {
	return p.OBSClient.StopRecord(ctx, req)
}
func (p *Proxy) ToggleRecordPause(ctx context.Context, req *obsgrpc.ToggleRecordPauseRequest) (_ret *obsgrpc.ToggleRecordPauseResponse, _err error) {
	logger.Debugf(ctx, "ToggleRecordPause")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/ToggleRecordPause: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &record.ToggleRecordPauseParams{}
	if req != nil {
		params = &record.ToggleRecordPauseParams{}
	}
	resp, err := client.Record.ToggleRecordPause(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.ToggleRecordPauseResponse{}
	return result, nil
}
func (p *ProxyAsClient) ToggleRecordPause(ctx context.Context, req *obsgrpc.ToggleRecordPauseRequest, opts ...grpc.CallOption) (*obsgrpc.ToggleRecordPauseResponse, error) {
	return (*Proxy)(p).ToggleRecordPause(ctx, req)
}
func (p *ClientAsServer) ToggleRecordPause(ctx context.Context, req *obsgrpc.ToggleRecordPauseRequest) (*obsgrpc.ToggleRecordPauseResponse, error) {
	return p.OBSClient.ToggleRecordPause(ctx, req)
}
func (p *Proxy) PauseRecord(ctx context.Context, req *obsgrpc.PauseRecordRequest) (_ret *obsgrpc.PauseRecordResponse, _err error) {
	logger.Debugf(ctx, "PauseRecord")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/PauseRecord: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &record.PauseRecordParams{}
	if req != nil {
		params = &record.PauseRecordParams{}
	}
	resp, err := client.Record.PauseRecord(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.PauseRecordResponse{}
	return result, nil
}
func (p *ProxyAsClient) PauseRecord(ctx context.Context, req *obsgrpc.PauseRecordRequest, opts ...grpc.CallOption) (*obsgrpc.PauseRecordResponse, error) {
	return (*Proxy)(p).PauseRecord(ctx, req)
}
func (p *ClientAsServer) PauseRecord(ctx context.Context, req *obsgrpc.PauseRecordRequest) (*obsgrpc.PauseRecordResponse, error) {
	return p.OBSClient.PauseRecord(ctx, req)
}
func (p *Proxy) ResumeRecord(ctx context.Context, req *obsgrpc.ResumeRecordRequest) (_ret *obsgrpc.ResumeRecordResponse, _err error) {
	logger.Debugf(ctx, "ResumeRecord")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/ResumeRecord: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &record.ResumeRecordParams{}
	if req != nil {
		params = &record.ResumeRecordParams{}
	}
	resp, err := client.Record.ResumeRecord(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.ResumeRecordResponse{}
	return result, nil
}
func (p *ProxyAsClient) ResumeRecord(ctx context.Context, req *obsgrpc.ResumeRecordRequest, opts ...grpc.CallOption) (*obsgrpc.ResumeRecordResponse, error) {
	return (*Proxy)(p).ResumeRecord(ctx, req)
}
func (p *ClientAsServer) ResumeRecord(ctx context.Context, req *obsgrpc.ResumeRecordRequest) (*obsgrpc.ResumeRecordResponse, error) {
	return p.OBSClient.ResumeRecord(ctx, req)
}
func (p *Proxy) SplitRecordFile(ctx context.Context, req *obsgrpc.SplitRecordFileRequest) (_ret *obsgrpc.SplitRecordFileResponse, _err error) {
	logger.Debugf(ctx, "SplitRecordFile")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/SplitRecordFile: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &record.SplitRecordFileParams{}
	if req != nil {
		params = &record.SplitRecordFileParams{}
	}
	resp, err := client.Record.SplitRecordFile(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.SplitRecordFileResponse{}
	return result, nil
}
func (p *ProxyAsClient) SplitRecordFile(ctx context.Context, req *obsgrpc.SplitRecordFileRequest, opts ...grpc.CallOption) (*obsgrpc.SplitRecordFileResponse, error) {
	return (*Proxy)(p).SplitRecordFile(ctx, req)
}
func (p *ClientAsServer) SplitRecordFile(ctx context.Context, req *obsgrpc.SplitRecordFileRequest) (*obsgrpc.SplitRecordFileResponse, error) {
	return p.OBSClient.SplitRecordFile(ctx, req)
}
func (p *Proxy) CreateRecordChapter(ctx context.Context, req *obsgrpc.CreateRecordChapterRequest) (_ret *obsgrpc.CreateRecordChapterResponse, _err error) {
	logger.Debugf(ctx, "CreateRecordChapter")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/CreateRecordChapter: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &record.CreateRecordChapterParams{}
	if req != nil {
		params = &record.CreateRecordChapterParams{
			ChapterName: req.ChapterName,
		}
	}
	resp, err := client.Record.CreateRecordChapter(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.CreateRecordChapterResponse{}
	return result, nil
}
func (p *ProxyAsClient) CreateRecordChapter(ctx context.Context, req *obsgrpc.CreateRecordChapterRequest, opts ...grpc.CallOption) (*obsgrpc.CreateRecordChapterResponse, error) {
	return (*Proxy)(p).CreateRecordChapter(ctx, req)
}
func (p *ClientAsServer) CreateRecordChapter(ctx context.Context, req *obsgrpc.CreateRecordChapterRequest) (*obsgrpc.CreateRecordChapterResponse, error) {
	return p.OBSClient.CreateRecordChapter(ctx, req)
}
func (p *Proxy) GetSceneItemList(ctx context.Context, req *obsgrpc.GetSceneItemListRequest) (_ret *obsgrpc.GetSceneItemListResponse, _err error) {
	logger.Debugf(ctx, "GetSceneItemList")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/GetSceneItemList: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &sceneitems.GetSceneItemListParams{}
	if req != nil {
		params = &sceneitems.GetSceneItemListParams{
			SceneName: req.SceneName,
			SceneUuid: req.SceneUUID,
		}
	}
	resp, err := client.SceneItems.GetSceneItemList(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.GetSceneItemListResponse{
		SceneItems: toAbstractObjects[*typedefs.SceneItem](resp.SceneItems),
	}
	return result, nil
}
func (p *ProxyAsClient) GetSceneItemList(ctx context.Context, req *obsgrpc.GetSceneItemListRequest, opts ...grpc.CallOption) (*obsgrpc.GetSceneItemListResponse, error) {
	return (*Proxy)(p).GetSceneItemList(ctx, req)
}
func (p *ClientAsServer) GetSceneItemList(ctx context.Context, req *obsgrpc.GetSceneItemListRequest) (*obsgrpc.GetSceneItemListResponse, error) {
	return p.OBSClient.GetSceneItemList(ctx, req)
}
func (p *Proxy) GetGroupSceneItemList(ctx context.Context, req *obsgrpc.GetGroupSceneItemListRequest) (_ret *obsgrpc.GetGroupSceneItemListResponse, _err error) {
	logger.Debugf(ctx, "GetGroupSceneItemList")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/GetGroupSceneItemList: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &sceneitems.GetGroupSceneItemListParams{}
	if req != nil {
		params = &sceneitems.GetGroupSceneItemListParams{
			SceneName: req.SceneName,
			SceneUuid: req.SceneUUID,
		}
	}
	resp, err := client.SceneItems.GetGroupSceneItemList(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.GetGroupSceneItemListResponse{
		SceneItems: toAbstractObjects[*typedefs.SceneItem](resp.SceneItems),
	}
	return result, nil
}
func (p *ProxyAsClient) GetGroupSceneItemList(ctx context.Context, req *obsgrpc.GetGroupSceneItemListRequest, opts ...grpc.CallOption) (*obsgrpc.GetGroupSceneItemListResponse, error) {
	return (*Proxy)(p).GetGroupSceneItemList(ctx, req)
}
func (p *ClientAsServer) GetGroupSceneItemList(ctx context.Context, req *obsgrpc.GetGroupSceneItemListRequest) (*obsgrpc.GetGroupSceneItemListResponse, error) {
	return p.OBSClient.GetGroupSceneItemList(ctx, req)
}
func (p *Proxy) GetSceneItemId(ctx context.Context, req *obsgrpc.GetSceneItemIdRequest) (_ret *obsgrpc.GetSceneItemIdResponse, _err error) {
	logger.Debugf(ctx, "GetSceneItemId")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/GetSceneItemId: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &sceneitems.GetSceneItemIdParams{}
	if req != nil {
		params = &sceneitems.GetSceneItemIdParams{
			SceneName:    req.SceneName,
			SceneUuid:    req.SceneUUID,
			SourceName:   ptr(req.SourceName),
			SearchOffset: ptrInt64ToFloat64(req.SearchOffset),
		}
	}
	resp, err := client.SceneItems.GetSceneItemId(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.GetSceneItemIdResponse{
		SceneItemID: (int64)(resp.SceneItemId),
	}
	return result, nil
}
func (p *ProxyAsClient) GetSceneItemId(ctx context.Context, req *obsgrpc.GetSceneItemIdRequest, opts ...grpc.CallOption) (*obsgrpc.GetSceneItemIdResponse, error) {
	return (*Proxy)(p).GetSceneItemId(ctx, req)
}
func (p *ClientAsServer) GetSceneItemId(ctx context.Context, req *obsgrpc.GetSceneItemIdRequest) (*obsgrpc.GetSceneItemIdResponse, error) {
	return p.OBSClient.GetSceneItemId(ctx, req)
}
func (p *Proxy) GetSceneItemSource(ctx context.Context, req *obsgrpc.GetSceneItemSourceRequest) (_ret *obsgrpc.GetSceneItemSourceResponse, _err error) {
	logger.Debugf(ctx, "GetSceneItemSource")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/GetSceneItemSource: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &sceneitems.GetSceneItemSourceParams{}
	if req != nil {
		params = &sceneitems.GetSceneItemSourceParams{
			SceneName:   req.SceneName,
			SceneUuid:   req.SceneUUID,
			SceneItemId: ptr((int)(req.SceneItemID)),
		}
	}
	resp, err := client.SceneItems.GetSceneItemSource(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.GetSceneItemSourceResponse{
		SourceName: resp.SourceName,
		SourceUUID: resp.SourceUuid,
	}
	return result, nil
}
func (p *ProxyAsClient) GetSceneItemSource(ctx context.Context, req *obsgrpc.GetSceneItemSourceRequest, opts ...grpc.CallOption) (*obsgrpc.GetSceneItemSourceResponse, error) {
	return (*Proxy)(p).GetSceneItemSource(ctx, req)
}
func (p *ClientAsServer) GetSceneItemSource(ctx context.Context, req *obsgrpc.GetSceneItemSourceRequest) (*obsgrpc.GetSceneItemSourceResponse, error) {
	return p.OBSClient.GetSceneItemSource(ctx, req)
}
func (p *Proxy) CreateSceneItem(ctx context.Context, req *obsgrpc.CreateSceneItemRequest) (_ret *obsgrpc.CreateSceneItemResponse, _err error) {
	logger.Debugf(ctx, "CreateSceneItem")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/CreateSceneItem: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &sceneitems.CreateSceneItemParams{}
	if req != nil {
		params = &sceneitems.CreateSceneItemParams{
			SceneName:        req.SceneName,
			SceneUuid:        req.SceneUUID,
			SourceName:       req.SourceName,
			SourceUuid:       req.SourceUUID,
			SceneItemEnabled: req.SceneItemEnabled,
		}
	}
	resp, err := client.SceneItems.CreateSceneItem(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.CreateSceneItemResponse{
		SceneItemID: (int64)(resp.SceneItemId),
	}
	return result, nil
}
func (p *ProxyAsClient) CreateSceneItem(ctx context.Context, req *obsgrpc.CreateSceneItemRequest, opts ...grpc.CallOption) (*obsgrpc.CreateSceneItemResponse, error) {
	return (*Proxy)(p).CreateSceneItem(ctx, req)
}
func (p *ClientAsServer) CreateSceneItem(ctx context.Context, req *obsgrpc.CreateSceneItemRequest) (*obsgrpc.CreateSceneItemResponse, error) {
	return p.OBSClient.CreateSceneItem(ctx, req)
}
func (p *Proxy) RemoveSceneItem(ctx context.Context, req *obsgrpc.RemoveSceneItemRequest) (_ret *obsgrpc.RemoveSceneItemResponse, _err error) {
	logger.Debugf(ctx, "RemoveSceneItem")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/RemoveSceneItem: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &sceneitems.RemoveSceneItemParams{}
	if req != nil {
		params = &sceneitems.RemoveSceneItemParams{
			SceneName:   req.SceneName,
			SceneUuid:   req.SceneUUID,
			SceneItemId: ptr((int)(req.SceneItemID)),
		}
	}
	resp, err := client.SceneItems.RemoveSceneItem(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.RemoveSceneItemResponse{}
	return result, nil
}
func (p *ProxyAsClient) RemoveSceneItem(ctx context.Context, req *obsgrpc.RemoveSceneItemRequest, opts ...grpc.CallOption) (*obsgrpc.RemoveSceneItemResponse, error) {
	return (*Proxy)(p).RemoveSceneItem(ctx, req)
}
func (p *ClientAsServer) RemoveSceneItem(ctx context.Context, req *obsgrpc.RemoveSceneItemRequest) (*obsgrpc.RemoveSceneItemResponse, error) {
	return p.OBSClient.RemoveSceneItem(ctx, req)
}
func (p *Proxy) DuplicateSceneItem(ctx context.Context, req *obsgrpc.DuplicateSceneItemRequest) (_ret *obsgrpc.DuplicateSceneItemResponse, _err error) {
	logger.Debugf(ctx, "DuplicateSceneItem")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/DuplicateSceneItem: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &sceneitems.DuplicateSceneItemParams{}
	if req != nil {
		params = &sceneitems.DuplicateSceneItemParams{
			SceneName:            req.SceneName,
			SceneUuid:            req.SceneUUID,
			SceneItemId:          ptr((int)(req.SceneItemID)),
			DestinationSceneName: req.DestinationSceneName,
			DestinationSceneUuid: req.DestinationSceneUUID,
		}
	}
	resp, err := client.SceneItems.DuplicateSceneItem(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.DuplicateSceneItemResponse{
		SceneItemID: (int64)(resp.SceneItemId),
	}
	return result, nil
}
func (p *ProxyAsClient) DuplicateSceneItem(ctx context.Context, req *obsgrpc.DuplicateSceneItemRequest, opts ...grpc.CallOption) (*obsgrpc.DuplicateSceneItemResponse, error) {
	return (*Proxy)(p).DuplicateSceneItem(ctx, req)
}
func (p *ClientAsServer) DuplicateSceneItem(ctx context.Context, req *obsgrpc.DuplicateSceneItemRequest) (*obsgrpc.DuplicateSceneItemResponse, error) {
	return p.OBSClient.DuplicateSceneItem(ctx, req)
}
func (p *Proxy) GetSceneItemTransform(ctx context.Context, req *obsgrpc.GetSceneItemTransformRequest) (_ret *obsgrpc.GetSceneItemTransformResponse, _err error) {
	logger.Debugf(ctx, "GetSceneItemTransform")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/GetSceneItemTransform: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &sceneitems.GetSceneItemTransformParams{}
	if req != nil {
		params = &sceneitems.GetSceneItemTransformParams{
			SceneName:   req.SceneName,
			SceneUuid:   req.SceneUUID,
			SceneItemId: ptr((int)(req.SceneItemID)),
		}
	}
	resp, err := client.SceneItems.GetSceneItemTransform(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.GetSceneItemTransformResponse{
		SceneItemTransform: toAbstractObject[*typedefs.SceneItemTransform](resp.SceneItemTransform),
	}
	return result, nil
}
func (p *ProxyAsClient) GetSceneItemTransform(ctx context.Context, req *obsgrpc.GetSceneItemTransformRequest, opts ...grpc.CallOption) (*obsgrpc.GetSceneItemTransformResponse, error) {
	return (*Proxy)(p).GetSceneItemTransform(ctx, req)
}
func (p *ClientAsServer) GetSceneItemTransform(ctx context.Context, req *obsgrpc.GetSceneItemTransformRequest) (*obsgrpc.GetSceneItemTransformResponse, error) {
	return p.OBSClient.GetSceneItemTransform(ctx, req)
}
func (p *Proxy) SetSceneItemTransform(ctx context.Context, req *obsgrpc.SetSceneItemTransformRequest) (_ret *obsgrpc.SetSceneItemTransformResponse, _err error) {
	logger.Debugf(ctx, "SetSceneItemTransform")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/SetSceneItemTransform: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &sceneitems.SetSceneItemTransformParams{}
	if req != nil {
		params = &sceneitems.SetSceneItemTransformParams{
			SceneName:          req.SceneName,
			SceneUuid:          req.SceneUUID,
			SceneItemId:        ptr((int)(req.SceneItemID)),
			SceneItemTransform: fromAbstractObject[*typedefs.SceneItemTransform](req.SceneItemTransform),
		}
	}
	resp, err := client.SceneItems.SetSceneItemTransform(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.SetSceneItemTransformResponse{}
	return result, nil
}
func (p *ProxyAsClient) SetSceneItemTransform(ctx context.Context, req *obsgrpc.SetSceneItemTransformRequest, opts ...grpc.CallOption) (*obsgrpc.SetSceneItemTransformResponse, error) {
	return (*Proxy)(p).SetSceneItemTransform(ctx, req)
}
func (p *ClientAsServer) SetSceneItemTransform(ctx context.Context, req *obsgrpc.SetSceneItemTransformRequest) (*obsgrpc.SetSceneItemTransformResponse, error) {
	return p.OBSClient.SetSceneItemTransform(ctx, req)
}
func (p *Proxy) GetSceneItemEnabled(ctx context.Context, req *obsgrpc.GetSceneItemEnabledRequest) (_ret *obsgrpc.GetSceneItemEnabledResponse, _err error) {
	logger.Debugf(ctx, "GetSceneItemEnabled")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/GetSceneItemEnabled: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &sceneitems.GetSceneItemEnabledParams{}
	if req != nil {
		params = &sceneitems.GetSceneItemEnabledParams{
			SceneName:   req.SceneName,
			SceneUuid:   req.SceneUUID,
			SceneItemId: ptr((int)(req.SceneItemID)),
		}
	}
	resp, err := client.SceneItems.GetSceneItemEnabled(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.GetSceneItemEnabledResponse{
		SceneItemEnabled: resp.SceneItemEnabled,
	}
	return result, nil
}
func (p *ProxyAsClient) GetSceneItemEnabled(ctx context.Context, req *obsgrpc.GetSceneItemEnabledRequest, opts ...grpc.CallOption) (*obsgrpc.GetSceneItemEnabledResponse, error) {
	return (*Proxy)(p).GetSceneItemEnabled(ctx, req)
}
func (p *ClientAsServer) GetSceneItemEnabled(ctx context.Context, req *obsgrpc.GetSceneItemEnabledRequest) (*obsgrpc.GetSceneItemEnabledResponse, error) {
	return p.OBSClient.GetSceneItemEnabled(ctx, req)
}
func (p *Proxy) SetSceneItemEnabled(ctx context.Context, req *obsgrpc.SetSceneItemEnabledRequest) (_ret *obsgrpc.SetSceneItemEnabledResponse, _err error) {
	logger.Debugf(ctx, "SetSceneItemEnabled")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/SetSceneItemEnabled: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &sceneitems.SetSceneItemEnabledParams{}
	if req != nil {
		params = &sceneitems.SetSceneItemEnabledParams{
			SceneName:        req.SceneName,
			SceneUuid:        req.SceneUUID,
			SceneItemId:      ptr((int)(req.SceneItemID)),
			SceneItemEnabled: ptr(req.SceneItemEnabled),
		}
	}
	resp, err := client.SceneItems.SetSceneItemEnabled(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.SetSceneItemEnabledResponse{}
	return result, nil
}
func (p *ProxyAsClient) SetSceneItemEnabled(ctx context.Context, req *obsgrpc.SetSceneItemEnabledRequest, opts ...grpc.CallOption) (*obsgrpc.SetSceneItemEnabledResponse, error) {
	return (*Proxy)(p).SetSceneItemEnabled(ctx, req)
}
func (p *ClientAsServer) SetSceneItemEnabled(ctx context.Context, req *obsgrpc.SetSceneItemEnabledRequest) (*obsgrpc.SetSceneItemEnabledResponse, error) {
	return p.OBSClient.SetSceneItemEnabled(ctx, req)
}
func (p *Proxy) GetSceneItemLocked(ctx context.Context, req *obsgrpc.GetSceneItemLockedRequest) (_ret *obsgrpc.GetSceneItemLockedResponse, _err error) {
	logger.Debugf(ctx, "GetSceneItemLocked")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/GetSceneItemLocked: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &sceneitems.GetSceneItemLockedParams{}
	if req != nil {
		params = &sceneitems.GetSceneItemLockedParams{
			SceneName:   req.SceneName,
			SceneUuid:   req.SceneUUID,
			SceneItemId: ptr((int)(req.SceneItemID)),
		}
	}
	resp, err := client.SceneItems.GetSceneItemLocked(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.GetSceneItemLockedResponse{
		SceneItemLocked: resp.SceneItemLocked,
	}
	return result, nil
}
func (p *ProxyAsClient) GetSceneItemLocked(ctx context.Context, req *obsgrpc.GetSceneItemLockedRequest, opts ...grpc.CallOption) (*obsgrpc.GetSceneItemLockedResponse, error) {
	return (*Proxy)(p).GetSceneItemLocked(ctx, req)
}
func (p *ClientAsServer) GetSceneItemLocked(ctx context.Context, req *obsgrpc.GetSceneItemLockedRequest) (*obsgrpc.GetSceneItemLockedResponse, error) {
	return p.OBSClient.GetSceneItemLocked(ctx, req)
}
func (p *Proxy) SetSceneItemLocked(ctx context.Context, req *obsgrpc.SetSceneItemLockedRequest) (_ret *obsgrpc.SetSceneItemLockedResponse, _err error) {
	logger.Debugf(ctx, "SetSceneItemLocked")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/SetSceneItemLocked: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &sceneitems.SetSceneItemLockedParams{}
	if req != nil {
		params = &sceneitems.SetSceneItemLockedParams{
			SceneName:       req.SceneName,
			SceneUuid:       req.SceneUUID,
			SceneItemId:     ptr((int)(req.SceneItemID)),
			SceneItemLocked: ptr(req.SceneItemLocked),
		}
	}
	resp, err := client.SceneItems.SetSceneItemLocked(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.SetSceneItemLockedResponse{}
	return result, nil
}
func (p *ProxyAsClient) SetSceneItemLocked(ctx context.Context, req *obsgrpc.SetSceneItemLockedRequest, opts ...grpc.CallOption) (*obsgrpc.SetSceneItemLockedResponse, error) {
	return (*Proxy)(p).SetSceneItemLocked(ctx, req)
}
func (p *ClientAsServer) SetSceneItemLocked(ctx context.Context, req *obsgrpc.SetSceneItemLockedRequest) (*obsgrpc.SetSceneItemLockedResponse, error) {
	return p.OBSClient.SetSceneItemLocked(ctx, req)
}
func (p *Proxy) GetSceneItemIndex(ctx context.Context, req *obsgrpc.GetSceneItemIndexRequest) (_ret *obsgrpc.GetSceneItemIndexResponse, _err error) {
	logger.Debugf(ctx, "GetSceneItemIndex")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/GetSceneItemIndex: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &sceneitems.GetSceneItemIndexParams{}
	if req != nil {
		params = &sceneitems.GetSceneItemIndexParams{
			SceneName:   req.SceneName,
			SceneUuid:   req.SceneUUID,
			SceneItemId: ptr((int)(req.SceneItemID)),
		}
	}
	resp, err := client.SceneItems.GetSceneItemIndex(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.GetSceneItemIndexResponse{
		SceneItemIndex: (int64)(resp.SceneItemIndex),
	}
	return result, nil
}
func (p *ProxyAsClient) GetSceneItemIndex(ctx context.Context, req *obsgrpc.GetSceneItemIndexRequest, opts ...grpc.CallOption) (*obsgrpc.GetSceneItemIndexResponse, error) {
	return (*Proxy)(p).GetSceneItemIndex(ctx, req)
}
func (p *ClientAsServer) GetSceneItemIndex(ctx context.Context, req *obsgrpc.GetSceneItemIndexRequest) (*obsgrpc.GetSceneItemIndexResponse, error) {
	return p.OBSClient.GetSceneItemIndex(ctx, req)
}
func (p *Proxy) SetSceneItemIndex(ctx context.Context, req *obsgrpc.SetSceneItemIndexRequest) (_ret *obsgrpc.SetSceneItemIndexResponse, _err error) {
	logger.Debugf(ctx, "SetSceneItemIndex")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/SetSceneItemIndex: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &sceneitems.SetSceneItemIndexParams{}
	if req != nil {
		params = &sceneitems.SetSceneItemIndexParams{
			SceneName:      req.SceneName,
			SceneUuid:      req.SceneUUID,
			SceneItemId:    ptr((int)(req.SceneItemID)),
			SceneItemIndex: ptr((int)(req.SceneItemIndex)),
		}
	}
	resp, err := client.SceneItems.SetSceneItemIndex(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.SetSceneItemIndexResponse{}
	return result, nil
}
func (p *ProxyAsClient) SetSceneItemIndex(ctx context.Context, req *obsgrpc.SetSceneItemIndexRequest, opts ...grpc.CallOption) (*obsgrpc.SetSceneItemIndexResponse, error) {
	return (*Proxy)(p).SetSceneItemIndex(ctx, req)
}
func (p *ClientAsServer) SetSceneItemIndex(ctx context.Context, req *obsgrpc.SetSceneItemIndexRequest) (*obsgrpc.SetSceneItemIndexResponse, error) {
	return p.OBSClient.SetSceneItemIndex(ctx, req)
}
func (p *Proxy) GetSceneItemBlendMode(ctx context.Context, req *obsgrpc.GetSceneItemBlendModeRequest) (_ret *obsgrpc.GetSceneItemBlendModeResponse, _err error) {
	logger.Debugf(ctx, "GetSceneItemBlendMode")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/GetSceneItemBlendMode: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &sceneitems.GetSceneItemBlendModeParams{}
	if req != nil {
		params = &sceneitems.GetSceneItemBlendModeParams{
			SceneName:   req.SceneName,
			SceneUuid:   req.SceneUUID,
			SceneItemId: ptr((int)(req.SceneItemID)),
		}
	}
	resp, err := client.SceneItems.GetSceneItemBlendMode(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.GetSceneItemBlendModeResponse{
		SceneItemBlendMode: ([]byte)(resp.SceneItemBlendMode),
	}
	return result, nil
}
func (p *ProxyAsClient) GetSceneItemBlendMode(ctx context.Context, req *obsgrpc.GetSceneItemBlendModeRequest, opts ...grpc.CallOption) (*obsgrpc.GetSceneItemBlendModeResponse, error) {
	return (*Proxy)(p).GetSceneItemBlendMode(ctx, req)
}
func (p *ClientAsServer) GetSceneItemBlendMode(ctx context.Context, req *obsgrpc.GetSceneItemBlendModeRequest) (*obsgrpc.GetSceneItemBlendModeResponse, error) {
	return p.OBSClient.GetSceneItemBlendMode(ctx, req)
}
func (p *Proxy) SetSceneItemBlendMode(ctx context.Context, req *obsgrpc.SetSceneItemBlendModeRequest) (_ret *obsgrpc.SetSceneItemBlendModeResponse, _err error) {
	logger.Debugf(ctx, "SetSceneItemBlendMode")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/SetSceneItemBlendMode: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &sceneitems.SetSceneItemBlendModeParams{}
	if req != nil {
		params = &sceneitems.SetSceneItemBlendModeParams{
			SceneName:          req.SceneName,
			SceneUuid:          req.SceneUUID,
			SceneItemId:        ptr((int)(req.SceneItemID)),
			SceneItemBlendMode: ptr((string)(req.SceneItemBlendMode)),
		}
	}
	resp, err := client.SceneItems.SetSceneItemBlendMode(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.SetSceneItemBlendModeResponse{}
	return result, nil
}
func (p *ProxyAsClient) SetSceneItemBlendMode(ctx context.Context, req *obsgrpc.SetSceneItemBlendModeRequest, opts ...grpc.CallOption) (*obsgrpc.SetSceneItemBlendModeResponse, error) {
	return (*Proxy)(p).SetSceneItemBlendMode(ctx, req)
}
func (p *ClientAsServer) SetSceneItemBlendMode(ctx context.Context, req *obsgrpc.SetSceneItemBlendModeRequest) (*obsgrpc.SetSceneItemBlendModeResponse, error) {
	return p.OBSClient.SetSceneItemBlendMode(ctx, req)
}
func (p *Proxy) GetSceneList(ctx context.Context, req *obsgrpc.GetSceneListRequest) (_ret *obsgrpc.GetSceneListResponse, _err error) {
	logger.Debugf(ctx, "GetSceneList")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/GetSceneList: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &scenes.GetSceneListParams{}
	if req != nil {
		params = &scenes.GetSceneListParams{}
	}
	resp, err := client.Scenes.GetSceneList(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.GetSceneListResponse{
		CurrentProgramSceneName: resp.CurrentProgramSceneName,
		CurrentProgramSceneUUID: resp.CurrentProgramSceneUuid,
		CurrentPreviewSceneName: resp.CurrentPreviewSceneName,
		CurrentPreviewSceneUUID: resp.CurrentPreviewSceneUuid,
		Scenes:                  toAbstractObjects[*typedefs.Scene](resp.Scenes),
	}
	return result, nil
}
func (p *ProxyAsClient) GetSceneList(ctx context.Context, req *obsgrpc.GetSceneListRequest, opts ...grpc.CallOption) (*obsgrpc.GetSceneListResponse, error) {
	return (*Proxy)(p).GetSceneList(ctx, req)
}
func (p *ClientAsServer) GetSceneList(ctx context.Context, req *obsgrpc.GetSceneListRequest) (*obsgrpc.GetSceneListResponse, error) {
	return p.OBSClient.GetSceneList(ctx, req)
}
func (p *Proxy) GetGroupList(ctx context.Context, req *obsgrpc.GetGroupListRequest) (_ret *obsgrpc.GetGroupListResponse, _err error) {
	logger.Debugf(ctx, "GetGroupList")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/GetGroupList: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &scenes.GetGroupListParams{}
	if req != nil {
		params = &scenes.GetGroupListParams{}
	}
	resp, err := client.Scenes.GetGroupList(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.GetGroupListResponse{
		Groups: stringSlice2BytesSlice(resp.Groups),
	}
	return result, nil
}
func (p *ProxyAsClient) GetGroupList(ctx context.Context, req *obsgrpc.GetGroupListRequest, opts ...grpc.CallOption) (*obsgrpc.GetGroupListResponse, error) {
	return (*Proxy)(p).GetGroupList(ctx, req)
}
func (p *ClientAsServer) GetGroupList(ctx context.Context, req *obsgrpc.GetGroupListRequest) (*obsgrpc.GetGroupListResponse, error) {
	return p.OBSClient.GetGroupList(ctx, req)
}
func (p *Proxy) GetCurrentProgramScene(ctx context.Context, req *obsgrpc.GetCurrentProgramSceneRequest) (_ret *obsgrpc.GetCurrentProgramSceneResponse, _err error) {
	logger.Debugf(ctx, "GetCurrentProgramScene")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/GetCurrentProgramScene: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &scenes.GetCurrentProgramSceneParams{}
	if req != nil {
		params = &scenes.GetCurrentProgramSceneParams{}
	}
	resp, err := client.Scenes.GetCurrentProgramScene(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.GetCurrentProgramSceneResponse{
		SceneName:               resp.SceneName,
		SceneUUID:               resp.SceneUuid,
		CurrentProgramSceneName: resp.CurrentProgramSceneName,
		CurrentProgramSceneUUID: resp.CurrentProgramSceneUuid,
	}
	return result, nil
}
func (p *ProxyAsClient) GetCurrentProgramScene(ctx context.Context, req *obsgrpc.GetCurrentProgramSceneRequest, opts ...grpc.CallOption) (*obsgrpc.GetCurrentProgramSceneResponse, error) {
	return (*Proxy)(p).GetCurrentProgramScene(ctx, req)
}
func (p *ClientAsServer) GetCurrentProgramScene(ctx context.Context, req *obsgrpc.GetCurrentProgramSceneRequest) (*obsgrpc.GetCurrentProgramSceneResponse, error) {
	return p.OBSClient.GetCurrentProgramScene(ctx, req)
}
func (p *Proxy) SetCurrentProgramScene(ctx context.Context, req *obsgrpc.SetCurrentProgramSceneRequest) (_ret *obsgrpc.SetCurrentProgramSceneResponse, _err error) {
	logger.Debugf(ctx, "SetCurrentProgramScene")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/SetCurrentProgramScene: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &scenes.SetCurrentProgramSceneParams{}
	if req != nil {
		params = &scenes.SetCurrentProgramSceneParams{
			SceneName: req.SceneName,
			SceneUuid: req.SceneUUID,
		}
	}
	resp, err := client.Scenes.SetCurrentProgramScene(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.SetCurrentProgramSceneResponse{}
	return result, nil
}
func (p *ProxyAsClient) SetCurrentProgramScene(ctx context.Context, req *obsgrpc.SetCurrentProgramSceneRequest, opts ...grpc.CallOption) (*obsgrpc.SetCurrentProgramSceneResponse, error) {
	return (*Proxy)(p).SetCurrentProgramScene(ctx, req)
}
func (p *ClientAsServer) SetCurrentProgramScene(ctx context.Context, req *obsgrpc.SetCurrentProgramSceneRequest) (*obsgrpc.SetCurrentProgramSceneResponse, error) {
	return p.OBSClient.SetCurrentProgramScene(ctx, req)
}
func (p *Proxy) GetCurrentPreviewScene(ctx context.Context, req *obsgrpc.GetCurrentPreviewSceneRequest) (_ret *obsgrpc.GetCurrentPreviewSceneResponse, _err error) {
	logger.Debugf(ctx, "GetCurrentPreviewScene")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/GetCurrentPreviewScene: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &scenes.GetCurrentPreviewSceneParams{}
	if req != nil {
		params = &scenes.GetCurrentPreviewSceneParams{}
	}
	resp, err := client.Scenes.GetCurrentPreviewScene(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.GetCurrentPreviewSceneResponse{
		SceneName:               resp.SceneName,
		SceneUUID:               resp.SceneUuid,
		CurrentPreviewSceneName: resp.CurrentPreviewSceneName,
		CurrentPreviewSceneUUID: resp.CurrentPreviewSceneUuid,
	}
	return result, nil
}
func (p *ProxyAsClient) GetCurrentPreviewScene(ctx context.Context, req *obsgrpc.GetCurrentPreviewSceneRequest, opts ...grpc.CallOption) (*obsgrpc.GetCurrentPreviewSceneResponse, error) {
	return (*Proxy)(p).GetCurrentPreviewScene(ctx, req)
}
func (p *ClientAsServer) GetCurrentPreviewScene(ctx context.Context, req *obsgrpc.GetCurrentPreviewSceneRequest) (*obsgrpc.GetCurrentPreviewSceneResponse, error) {
	return p.OBSClient.GetCurrentPreviewScene(ctx, req)
}
func (p *Proxy) SetCurrentPreviewScene(ctx context.Context, req *obsgrpc.SetCurrentPreviewSceneRequest) (_ret *obsgrpc.SetCurrentPreviewSceneResponse, _err error) {
	logger.Debugf(ctx, "SetCurrentPreviewScene")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/SetCurrentPreviewScene: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &scenes.SetCurrentPreviewSceneParams{}
	if req != nil {
		params = &scenes.SetCurrentPreviewSceneParams{
			SceneName: req.SceneName,
			SceneUuid: req.SceneUUID,
		}
	}
	resp, err := client.Scenes.SetCurrentPreviewScene(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.SetCurrentPreviewSceneResponse{}
	return result, nil
}
func (p *ProxyAsClient) SetCurrentPreviewScene(ctx context.Context, req *obsgrpc.SetCurrentPreviewSceneRequest, opts ...grpc.CallOption) (*obsgrpc.SetCurrentPreviewSceneResponse, error) {
	return (*Proxy)(p).SetCurrentPreviewScene(ctx, req)
}
func (p *ClientAsServer) SetCurrentPreviewScene(ctx context.Context, req *obsgrpc.SetCurrentPreviewSceneRequest) (*obsgrpc.SetCurrentPreviewSceneResponse, error) {
	return p.OBSClient.SetCurrentPreviewScene(ctx, req)
}
func (p *Proxy) CreateScene(ctx context.Context, req *obsgrpc.CreateSceneRequest) (_ret *obsgrpc.CreateSceneResponse, _err error) {
	logger.Debugf(ctx, "CreateScene")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/CreateScene: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &scenes.CreateSceneParams{}
	if req != nil {
		params = &scenes.CreateSceneParams{
			SceneName: ptr(req.SceneName),
		}
	}
	resp, err := client.Scenes.CreateScene(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.CreateSceneResponse{
		SceneUUID: resp.SceneUuid,
	}
	return result, nil
}
func (p *ProxyAsClient) CreateScene(ctx context.Context, req *obsgrpc.CreateSceneRequest, opts ...grpc.CallOption) (*obsgrpc.CreateSceneResponse, error) {
	return (*Proxy)(p).CreateScene(ctx, req)
}
func (p *ClientAsServer) CreateScene(ctx context.Context, req *obsgrpc.CreateSceneRequest) (*obsgrpc.CreateSceneResponse, error) {
	return p.OBSClient.CreateScene(ctx, req)
}
func (p *Proxy) RemoveScene(ctx context.Context, req *obsgrpc.RemoveSceneRequest) (_ret *obsgrpc.RemoveSceneResponse, _err error) {
	logger.Debugf(ctx, "RemoveScene")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/RemoveScene: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &scenes.RemoveSceneParams{}
	if req != nil {
		params = &scenes.RemoveSceneParams{
			SceneName: req.SceneName,
			SceneUuid: req.SceneUUID,
		}
	}
	resp, err := client.Scenes.RemoveScene(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.RemoveSceneResponse{}
	return result, nil
}
func (p *ProxyAsClient) RemoveScene(ctx context.Context, req *obsgrpc.RemoveSceneRequest, opts ...grpc.CallOption) (*obsgrpc.RemoveSceneResponse, error) {
	return (*Proxy)(p).RemoveScene(ctx, req)
}
func (p *ClientAsServer) RemoveScene(ctx context.Context, req *obsgrpc.RemoveSceneRequest) (*obsgrpc.RemoveSceneResponse, error) {
	return p.OBSClient.RemoveScene(ctx, req)
}
func (p *Proxy) SetSceneName(ctx context.Context, req *obsgrpc.SetSceneNameRequest) (_ret *obsgrpc.SetSceneNameResponse, _err error) {
	logger.Debugf(ctx, "SetSceneName")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/SetSceneName: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &scenes.SetSceneNameParams{}
	if req != nil {
		params = &scenes.SetSceneNameParams{
			SceneName:    req.SceneName,
			SceneUuid:    req.SceneUUID,
			NewSceneName: ptr(req.NewSceneName),
		}
	}
	resp, err := client.Scenes.SetSceneName(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.SetSceneNameResponse{}
	return result, nil
}
func (p *ProxyAsClient) SetSceneName(ctx context.Context, req *obsgrpc.SetSceneNameRequest, opts ...grpc.CallOption) (*obsgrpc.SetSceneNameResponse, error) {
	return (*Proxy)(p).SetSceneName(ctx, req)
}
func (p *ClientAsServer) SetSceneName(ctx context.Context, req *obsgrpc.SetSceneNameRequest) (*obsgrpc.SetSceneNameResponse, error) {
	return p.OBSClient.SetSceneName(ctx, req)
}
func (p *Proxy) GetSceneSceneTransitionOverride(ctx context.Context, req *obsgrpc.GetSceneSceneTransitionOverrideRequest) (_ret *obsgrpc.GetSceneSceneTransitionOverrideResponse, _err error) {
	logger.Debugf(ctx, "GetSceneSceneTransitionOverride")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/GetSceneSceneTransitionOverride: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &scenes.GetSceneSceneTransitionOverrideParams{}
	if req != nil {
		params = &scenes.GetSceneSceneTransitionOverrideParams{
			SceneName: req.SceneName,
			SceneUuid: req.SceneUUID,
		}
	}
	resp, err := client.Scenes.GetSceneSceneTransitionOverride(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.GetSceneSceneTransitionOverrideResponse{
		TransitionName:     resp.TransitionName,
		TransitionDuration: (int64)(resp.TransitionDuration),
	}
	return result, nil
}
func (p *ProxyAsClient) GetSceneSceneTransitionOverride(ctx context.Context, req *obsgrpc.GetSceneSceneTransitionOverrideRequest, opts ...grpc.CallOption) (*obsgrpc.GetSceneSceneTransitionOverrideResponse, error) {
	return (*Proxy)(p).GetSceneSceneTransitionOverride(ctx, req)
}
func (p *ClientAsServer) GetSceneSceneTransitionOverride(ctx context.Context, req *obsgrpc.GetSceneSceneTransitionOverrideRequest) (*obsgrpc.GetSceneSceneTransitionOverrideResponse, error) {
	return p.OBSClient.GetSceneSceneTransitionOverride(ctx, req)
}
func (p *Proxy) SetSceneSceneTransitionOverride(ctx context.Context, req *obsgrpc.SetSceneSceneTransitionOverrideRequest) (_ret *obsgrpc.SetSceneSceneTransitionOverrideResponse, _err error) {
	logger.Debugf(ctx, "SetSceneSceneTransitionOverride")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/SetSceneSceneTransitionOverride: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &scenes.SetSceneSceneTransitionOverrideParams{}
	if req != nil {
		params = &scenes.SetSceneSceneTransitionOverrideParams{
			SceneName:          req.SceneName,
			SceneUuid:          req.SceneUUID,
			TransitionName:     req.TransitionName,
			TransitionDuration: ptrInt64ToFloat64(req.TransitionDuration),
		}
	}
	resp, err := client.Scenes.SetSceneSceneTransitionOverride(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.SetSceneSceneTransitionOverrideResponse{}
	return result, nil
}
func (p *ProxyAsClient) SetSceneSceneTransitionOverride(ctx context.Context, req *obsgrpc.SetSceneSceneTransitionOverrideRequest, opts ...grpc.CallOption) (*obsgrpc.SetSceneSceneTransitionOverrideResponse, error) {
	return (*Proxy)(p).SetSceneSceneTransitionOverride(ctx, req)
}
func (p *ClientAsServer) SetSceneSceneTransitionOverride(ctx context.Context, req *obsgrpc.SetSceneSceneTransitionOverrideRequest) (*obsgrpc.SetSceneSceneTransitionOverrideResponse, error) {
	return p.OBSClient.SetSceneSceneTransitionOverride(ctx, req)
}
func (p *Proxy) GetSourceActive(ctx context.Context, req *obsgrpc.GetSourceActiveRequest) (_ret *obsgrpc.GetSourceActiveResponse, _err error) {
	logger.Debugf(ctx, "GetSourceActive")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/GetSourceActive: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &sources.GetSourceActiveParams{}
	if req != nil {
		params = &sources.GetSourceActiveParams{
			SourceName: req.SourceName,
			SourceUuid: req.SourceUUID,
		}
	}
	resp, err := client.Sources.GetSourceActive(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.GetSourceActiveResponse{
		VideoActive:  resp.VideoActive,
		VideoShowing: resp.VideoShowing,
	}
	return result, nil
}
func (p *ProxyAsClient) GetSourceActive(ctx context.Context, req *obsgrpc.GetSourceActiveRequest, opts ...grpc.CallOption) (*obsgrpc.GetSourceActiveResponse, error) {
	return (*Proxy)(p).GetSourceActive(ctx, req)
}
func (p *ClientAsServer) GetSourceActive(ctx context.Context, req *obsgrpc.GetSourceActiveRequest) (*obsgrpc.GetSourceActiveResponse, error) {
	return p.OBSClient.GetSourceActive(ctx, req)
}
func (p *Proxy) GetSourceScreenshot(ctx context.Context, req *obsgrpc.GetSourceScreenshotRequest) (_ret *obsgrpc.GetSourceScreenshotResponse, _err error) {
	logger.Debugf(ctx, "GetSourceScreenshot")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/GetSourceScreenshot: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &sources.GetSourceScreenshotParams{}
	if req != nil {
		params = &sources.GetSourceScreenshotParams{
			SourceName:              req.SourceName,
			SourceUuid:              req.SourceUUID,
			ImageFormat:             ptr((string)(req.ImageFormat)),
			ImageWidth:              ptrInt64ToFloat64(req.ImageWidth),
			ImageHeight:             ptrInt64ToFloat64(req.ImageHeight),
			ImageCompressionQuality: ptrInt64ToFloat64(req.ImageCompressionQuality),
		}
	}
	resp, err := client.Sources.GetSourceScreenshot(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.GetSourceScreenshotResponse{
		ImageData: ([]byte)(resp.ImageData),
	}
	return result, nil
}
func (p *ProxyAsClient) GetSourceScreenshot(ctx context.Context, req *obsgrpc.GetSourceScreenshotRequest, opts ...grpc.CallOption) (*obsgrpc.GetSourceScreenshotResponse, error) {
	return (*Proxy)(p).GetSourceScreenshot(ctx, req)
}
func (p *ClientAsServer) GetSourceScreenshot(ctx context.Context, req *obsgrpc.GetSourceScreenshotRequest) (*obsgrpc.GetSourceScreenshotResponse, error) {
	return p.OBSClient.GetSourceScreenshot(ctx, req)
}
func (p *Proxy) SaveSourceScreenshot(ctx context.Context, req *obsgrpc.SaveSourceScreenshotRequest) (_ret *obsgrpc.SaveSourceScreenshotResponse, _err error) {
	logger.Debugf(ctx, "SaveSourceScreenshot")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/SaveSourceScreenshot: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &sources.SaveSourceScreenshotParams{}
	if req != nil {
		params = &sources.SaveSourceScreenshotParams{
			SourceName:              req.SourceName,
			SourceUuid:              req.SourceUUID,
			ImageFormat:             ptr((string)(req.ImageFormat)),
			ImageFilePath:           ptr(req.ImageFilePath),
			ImageWidth:              ptrInt64ToFloat64(req.ImageWidth),
			ImageHeight:             ptrInt64ToFloat64(req.ImageHeight),
			ImageCompressionQuality: ptrInt64ToFloat64(req.ImageCompressionQuality),
		}
	}
	resp, err := client.Sources.SaveSourceScreenshot(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.SaveSourceScreenshotResponse{}
	return result, nil
}
func (p *ProxyAsClient) SaveSourceScreenshot(ctx context.Context, req *obsgrpc.SaveSourceScreenshotRequest, opts ...grpc.CallOption) (*obsgrpc.SaveSourceScreenshotResponse, error) {
	return (*Proxy)(p).SaveSourceScreenshot(ctx, req)
}
func (p *ClientAsServer) SaveSourceScreenshot(ctx context.Context, req *obsgrpc.SaveSourceScreenshotRequest) (*obsgrpc.SaveSourceScreenshotResponse, error) {
	return p.OBSClient.SaveSourceScreenshot(ctx, req)
}
func (p *Proxy) GetStreamStatus(ctx context.Context, req *obsgrpc.GetStreamStatusRequest) (_ret *obsgrpc.GetStreamStatusResponse, _err error) {
	logger.Debugf(ctx, "GetStreamStatus")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/GetStreamStatus: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &stream.GetStreamStatusParams{}
	if req != nil {
		params = &stream.GetStreamStatusParams{}
	}
	resp, err := client.Stream.GetStreamStatus(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.GetStreamStatusResponse{
		OutputActive:        resp.OutputActive,
		OutputReconnecting:  resp.OutputReconnecting,
		OutputTimecode:      ([]byte)(resp.OutputTimecode),
		OutputDuration:      (int64)(resp.OutputDuration),
		OutputCongestion:    (int64)(resp.OutputCongestion),
		OutputBytes:         (int64)(resp.OutputBytes),
		OutputSkippedFrames: (int64)(resp.OutputSkippedFrames),
		OutputTotalFrames:   (int64)(resp.OutputTotalFrames),
	}
	return result, nil
}
func (p *ProxyAsClient) GetStreamStatus(ctx context.Context, req *obsgrpc.GetStreamStatusRequest, opts ...grpc.CallOption) (*obsgrpc.GetStreamStatusResponse, error) {
	return (*Proxy)(p).GetStreamStatus(ctx, req)
}
func (p *ClientAsServer) GetStreamStatus(ctx context.Context, req *obsgrpc.GetStreamStatusRequest) (*obsgrpc.GetStreamStatusResponse, error) {
	return p.OBSClient.GetStreamStatus(ctx, req)
}
func (p *Proxy) ToggleStream(ctx context.Context, req *obsgrpc.ToggleStreamRequest) (_ret *obsgrpc.ToggleStreamResponse, _err error) {
	logger.Debugf(ctx, "ToggleStream")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/ToggleStream: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &stream.ToggleStreamParams{}
	if req != nil {
		params = &stream.ToggleStreamParams{}
	}
	resp, err := client.Stream.ToggleStream(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.ToggleStreamResponse{
		OutputActive: resp.OutputActive,
	}
	return result, nil
}
func (p *ProxyAsClient) ToggleStream(ctx context.Context, req *obsgrpc.ToggleStreamRequest, opts ...grpc.CallOption) (*obsgrpc.ToggleStreamResponse, error) {
	return (*Proxy)(p).ToggleStream(ctx, req)
}
func (p *ClientAsServer) ToggleStream(ctx context.Context, req *obsgrpc.ToggleStreamRequest) (*obsgrpc.ToggleStreamResponse, error) {
	return p.OBSClient.ToggleStream(ctx, req)
}
func (p *Proxy) StartStream(ctx context.Context, req *obsgrpc.StartStreamRequest) (_ret *obsgrpc.StartStreamResponse, _err error) {
	logger.Debugf(ctx, "StartStream")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/StartStream: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &stream.StartStreamParams{}
	if req != nil {
		params = &stream.StartStreamParams{}
	}
	resp, err := client.Stream.StartStream(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.StartStreamResponse{}
	return result, nil
}
func (p *ProxyAsClient) StartStream(ctx context.Context, req *obsgrpc.StartStreamRequest, opts ...grpc.CallOption) (*obsgrpc.StartStreamResponse, error) {
	return (*Proxy)(p).StartStream(ctx, req)
}
func (p *ClientAsServer) StartStream(ctx context.Context, req *obsgrpc.StartStreamRequest) (*obsgrpc.StartStreamResponse, error) {
	return p.OBSClient.StartStream(ctx, req)
}
func (p *Proxy) StopStream(ctx context.Context, req *obsgrpc.StopStreamRequest) (_ret *obsgrpc.StopStreamResponse, _err error) {
	logger.Debugf(ctx, "StopStream")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/StopStream: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &stream.StopStreamParams{}
	if req != nil {
		params = &stream.StopStreamParams{}
	}
	resp, err := client.Stream.StopStream(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.StopStreamResponse{}
	return result, nil
}
func (p *ProxyAsClient) StopStream(ctx context.Context, req *obsgrpc.StopStreamRequest, opts ...grpc.CallOption) (*obsgrpc.StopStreamResponse, error) {
	return (*Proxy)(p).StopStream(ctx, req)
}
func (p *ClientAsServer) StopStream(ctx context.Context, req *obsgrpc.StopStreamRequest) (*obsgrpc.StopStreamResponse, error) {
	return p.OBSClient.StopStream(ctx, req)
}
func (p *Proxy) SendStreamCaption(ctx context.Context, req *obsgrpc.SendStreamCaptionRequest) (_ret *obsgrpc.SendStreamCaptionResponse, _err error) {
	logger.Debugf(ctx, "SendStreamCaption")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/SendStreamCaption: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &stream.SendStreamCaptionParams{}
	if req != nil {
		params = &stream.SendStreamCaptionParams{
			CaptionText: ptr((string)(req.CaptionText)),
		}
	}
	resp, err := client.Stream.SendStreamCaption(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.SendStreamCaptionResponse{}
	return result, nil
}
func (p *ProxyAsClient) SendStreamCaption(ctx context.Context, req *obsgrpc.SendStreamCaptionRequest, opts ...grpc.CallOption) (*obsgrpc.SendStreamCaptionResponse, error) {
	return (*Proxy)(p).SendStreamCaption(ctx, req)
}
func (p *ClientAsServer) SendStreamCaption(ctx context.Context, req *obsgrpc.SendStreamCaptionRequest) (*obsgrpc.SendStreamCaptionResponse, error) {
	return p.OBSClient.SendStreamCaption(ctx, req)
}
func (p *Proxy) GetTransitionKindList(ctx context.Context, req *obsgrpc.GetTransitionKindListRequest) (_ret *obsgrpc.GetTransitionKindListResponse, _err error) {
	logger.Debugf(ctx, "GetTransitionKindList")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/GetTransitionKindList: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &transitions.GetTransitionKindListParams{}
	if req != nil {
		params = &transitions.GetTransitionKindListParams{}
	}
	resp, err := client.Transitions.GetTransitionKindList(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.GetTransitionKindListResponse{
		TransitionKinds: resp.TransitionKinds,
	}
	return result, nil
}
func (p *ProxyAsClient) GetTransitionKindList(ctx context.Context, req *obsgrpc.GetTransitionKindListRequest, opts ...grpc.CallOption) (*obsgrpc.GetTransitionKindListResponse, error) {
	return (*Proxy)(p).GetTransitionKindList(ctx, req)
}
func (p *ClientAsServer) GetTransitionKindList(ctx context.Context, req *obsgrpc.GetTransitionKindListRequest) (*obsgrpc.GetTransitionKindListResponse, error) {
	return p.OBSClient.GetTransitionKindList(ctx, req)
}
func (p *Proxy) GetSceneTransitionList(ctx context.Context, req *obsgrpc.GetSceneTransitionListRequest) (_ret *obsgrpc.GetSceneTransitionListResponse, _err error) {
	logger.Debugf(ctx, "GetSceneTransitionList")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/GetSceneTransitionList: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &transitions.GetSceneTransitionListParams{}
	if req != nil {
		params = &transitions.GetSceneTransitionListParams{}
	}
	resp, err := client.Transitions.GetSceneTransitionList(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.GetSceneTransitionListResponse{
		CurrentSceneTransitionName: resp.CurrentSceneTransitionName,
		CurrentSceneTransitionUUID: resp.CurrentSceneTransitionUuid,
		CurrentSceneTransitionKind: resp.CurrentSceneTransitionKind,
		Transitions:                toAbstractObjects[*typedefs.Transition](resp.Transitions),
	}
	return result, nil
}
func (p *ProxyAsClient) GetSceneTransitionList(ctx context.Context, req *obsgrpc.GetSceneTransitionListRequest, opts ...grpc.CallOption) (*obsgrpc.GetSceneTransitionListResponse, error) {
	return (*Proxy)(p).GetSceneTransitionList(ctx, req)
}
func (p *ClientAsServer) GetSceneTransitionList(ctx context.Context, req *obsgrpc.GetSceneTransitionListRequest) (*obsgrpc.GetSceneTransitionListResponse, error) {
	return p.OBSClient.GetSceneTransitionList(ctx, req)
}
func (p *Proxy) GetCurrentSceneTransition(ctx context.Context, req *obsgrpc.GetCurrentSceneTransitionRequest) (_ret *obsgrpc.GetCurrentSceneTransitionResponse, _err error) {
	logger.Debugf(ctx, "GetCurrentSceneTransition")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/GetCurrentSceneTransition: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &transitions.GetCurrentSceneTransitionParams{}
	if req != nil {
		params = &transitions.GetCurrentSceneTransitionParams{}
	}
	resp, err := client.Transitions.GetCurrentSceneTransition(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.GetCurrentSceneTransitionResponse{
		TransitionName:         resp.TransitionName,
		TransitionUUID:         resp.TransitionUuid,
		TransitionKind:         resp.TransitionKind,
		TransitionFixed:        resp.TransitionFixed,
		TransitionDuration:     (int64)(resp.TransitionDuration),
		TransitionConfigurable: resp.TransitionConfigurable,
		TransitionSettings:     toAbstractObject[map[string]any](resp.TransitionSettings),
	}
	return result, nil
}
func (p *ProxyAsClient) GetCurrentSceneTransition(ctx context.Context, req *obsgrpc.GetCurrentSceneTransitionRequest, opts ...grpc.CallOption) (*obsgrpc.GetCurrentSceneTransitionResponse, error) {
	return (*Proxy)(p).GetCurrentSceneTransition(ctx, req)
}
func (p *ClientAsServer) GetCurrentSceneTransition(ctx context.Context, req *obsgrpc.GetCurrentSceneTransitionRequest) (*obsgrpc.GetCurrentSceneTransitionResponse, error) {
	return p.OBSClient.GetCurrentSceneTransition(ctx, req)
}
func (p *Proxy) SetCurrentSceneTransition(ctx context.Context, req *obsgrpc.SetCurrentSceneTransitionRequest) (_ret *obsgrpc.SetCurrentSceneTransitionResponse, _err error) {
	logger.Debugf(ctx, "SetCurrentSceneTransition")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/SetCurrentSceneTransition: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &transitions.SetCurrentSceneTransitionParams{}
	if req != nil {
		params = &transitions.SetCurrentSceneTransitionParams{
			TransitionName: ptr(req.TransitionName),
		}
	}
	resp, err := client.Transitions.SetCurrentSceneTransition(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.SetCurrentSceneTransitionResponse{}
	return result, nil
}
func (p *ProxyAsClient) SetCurrentSceneTransition(ctx context.Context, req *obsgrpc.SetCurrentSceneTransitionRequest, opts ...grpc.CallOption) (*obsgrpc.SetCurrentSceneTransitionResponse, error) {
	return (*Proxy)(p).SetCurrentSceneTransition(ctx, req)
}
func (p *ClientAsServer) SetCurrentSceneTransition(ctx context.Context, req *obsgrpc.SetCurrentSceneTransitionRequest) (*obsgrpc.SetCurrentSceneTransitionResponse, error) {
	return p.OBSClient.SetCurrentSceneTransition(ctx, req)
}
func (p *Proxy) SetCurrentSceneTransitionDuration(ctx context.Context, req *obsgrpc.SetCurrentSceneTransitionDurationRequest) (_ret *obsgrpc.SetCurrentSceneTransitionDurationResponse, _err error) {
	logger.Debugf(ctx, "SetCurrentSceneTransitionDuration")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/SetCurrentSceneTransitionDuration: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &transitions.SetCurrentSceneTransitionDurationParams{}
	if req != nil {
		params = &transitions.SetCurrentSceneTransitionDurationParams{
			TransitionDuration: ptr((float64)(req.TransitionDuration)),
		}
	}
	resp, err := client.Transitions.SetCurrentSceneTransitionDuration(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.SetCurrentSceneTransitionDurationResponse{}
	return result, nil
}
func (p *ProxyAsClient) SetCurrentSceneTransitionDuration(ctx context.Context, req *obsgrpc.SetCurrentSceneTransitionDurationRequest, opts ...grpc.CallOption) (*obsgrpc.SetCurrentSceneTransitionDurationResponse, error) {
	return (*Proxy)(p).SetCurrentSceneTransitionDuration(ctx, req)
}
func (p *ClientAsServer) SetCurrentSceneTransitionDuration(ctx context.Context, req *obsgrpc.SetCurrentSceneTransitionDurationRequest) (*obsgrpc.SetCurrentSceneTransitionDurationResponse, error) {
	return p.OBSClient.SetCurrentSceneTransitionDuration(ctx, req)
}
func (p *Proxy) SetCurrentSceneTransitionSettings(ctx context.Context, req *obsgrpc.SetCurrentSceneTransitionSettingsRequest) (_ret *obsgrpc.SetCurrentSceneTransitionSettingsResponse, _err error) {
	logger.Debugf(ctx, "SetCurrentSceneTransitionSettings")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/SetCurrentSceneTransitionSettings: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &transitions.SetCurrentSceneTransitionSettingsParams{}
	if req != nil {
		params = &transitions.SetCurrentSceneTransitionSettingsParams{
			TransitionSettings: fromAbstractObject[map[string]any](req.TransitionSettings),
			Overlay:            req.Overlay,
		}
	}
	resp, err := client.Transitions.SetCurrentSceneTransitionSettings(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.SetCurrentSceneTransitionSettingsResponse{}
	return result, nil
}
func (p *ProxyAsClient) SetCurrentSceneTransitionSettings(ctx context.Context, req *obsgrpc.SetCurrentSceneTransitionSettingsRequest, opts ...grpc.CallOption) (*obsgrpc.SetCurrentSceneTransitionSettingsResponse, error) {
	return (*Proxy)(p).SetCurrentSceneTransitionSettings(ctx, req)
}
func (p *ClientAsServer) SetCurrentSceneTransitionSettings(ctx context.Context, req *obsgrpc.SetCurrentSceneTransitionSettingsRequest) (*obsgrpc.SetCurrentSceneTransitionSettingsResponse, error) {
	return p.OBSClient.SetCurrentSceneTransitionSettings(ctx, req)
}
func (p *Proxy) GetCurrentSceneTransitionCursor(ctx context.Context, req *obsgrpc.GetCurrentSceneTransitionCursorRequest) (_ret *obsgrpc.GetCurrentSceneTransitionCursorResponse, _err error) {
	logger.Debugf(ctx, "GetCurrentSceneTransitionCursor")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/GetCurrentSceneTransitionCursor: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &transitions.GetCurrentSceneTransitionCursorParams{}
	if req != nil {
		params = &transitions.GetCurrentSceneTransitionCursorParams{}
	}
	resp, err := client.Transitions.GetCurrentSceneTransitionCursor(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.GetCurrentSceneTransitionCursorResponse{
		TransitionCursor: (int64)(resp.TransitionCursor),
	}
	return result, nil
}
func (p *ProxyAsClient) GetCurrentSceneTransitionCursor(ctx context.Context, req *obsgrpc.GetCurrentSceneTransitionCursorRequest, opts ...grpc.CallOption) (*obsgrpc.GetCurrentSceneTransitionCursorResponse, error) {
	return (*Proxy)(p).GetCurrentSceneTransitionCursor(ctx, req)
}
func (p *ClientAsServer) GetCurrentSceneTransitionCursor(ctx context.Context, req *obsgrpc.GetCurrentSceneTransitionCursorRequest) (*obsgrpc.GetCurrentSceneTransitionCursorResponse, error) {
	return p.OBSClient.GetCurrentSceneTransitionCursor(ctx, req)
}
func (p *Proxy) TriggerStudioModeTransition(ctx context.Context, req *obsgrpc.TriggerStudioModeTransitionRequest) (_ret *obsgrpc.TriggerStudioModeTransitionResponse, _err error) {
	logger.Debugf(ctx, "TriggerStudioModeTransition")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/TriggerStudioModeTransition: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &transitions.TriggerStudioModeTransitionParams{}
	if req != nil {
		params = &transitions.TriggerStudioModeTransitionParams{}
	}
	resp, err := client.Transitions.TriggerStudioModeTransition(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.TriggerStudioModeTransitionResponse{}
	return result, nil
}
func (p *ProxyAsClient) TriggerStudioModeTransition(ctx context.Context, req *obsgrpc.TriggerStudioModeTransitionRequest, opts ...grpc.CallOption) (*obsgrpc.TriggerStudioModeTransitionResponse, error) {
	return (*Proxy)(p).TriggerStudioModeTransition(ctx, req)
}
func (p *ClientAsServer) TriggerStudioModeTransition(ctx context.Context, req *obsgrpc.TriggerStudioModeTransitionRequest) (*obsgrpc.TriggerStudioModeTransitionResponse, error) {
	return p.OBSClient.TriggerStudioModeTransition(ctx, req)
}
func (p *Proxy) SetTBarPosition(ctx context.Context, req *obsgrpc.SetTBarPositionRequest) (_ret *obsgrpc.SetTBarPositionResponse, _err error) {
	logger.Debugf(ctx, "SetTBarPosition")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/SetTBarPosition: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &transitions.SetTBarPositionParams{}
	if req != nil {
		params = &transitions.SetTBarPositionParams{
			Position: ptr((float64)(req.Position)),
			Release:  req.Release,
		}
	}
	resp, err := client.Transitions.SetTBarPosition(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.SetTBarPositionResponse{}
	return result, nil
}
func (p *ProxyAsClient) SetTBarPosition(ctx context.Context, req *obsgrpc.SetTBarPositionRequest, opts ...grpc.CallOption) (*obsgrpc.SetTBarPositionResponse, error) {
	return (*Proxy)(p).SetTBarPosition(ctx, req)
}
func (p *ClientAsServer) SetTBarPosition(ctx context.Context, req *obsgrpc.SetTBarPositionRequest) (*obsgrpc.SetTBarPositionResponse, error) {
	return p.OBSClient.SetTBarPosition(ctx, req)
}
func (p *Proxy) GetStudioModeEnabled(ctx context.Context, req *obsgrpc.GetStudioModeEnabledRequest) (_ret *obsgrpc.GetStudioModeEnabledResponse, _err error) {
	logger.Debugf(ctx, "GetStudioModeEnabled")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/GetStudioModeEnabled: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &ui.GetStudioModeEnabledParams{}
	if req != nil {
		params = &ui.GetStudioModeEnabledParams{}
	}
	resp, err := client.Ui.GetStudioModeEnabled(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.GetStudioModeEnabledResponse{
		StudioModeEnabled: resp.StudioModeEnabled,
	}
	return result, nil
}
func (p *ProxyAsClient) GetStudioModeEnabled(ctx context.Context, req *obsgrpc.GetStudioModeEnabledRequest, opts ...grpc.CallOption) (*obsgrpc.GetStudioModeEnabledResponse, error) {
	return (*Proxy)(p).GetStudioModeEnabled(ctx, req)
}
func (p *ClientAsServer) GetStudioModeEnabled(ctx context.Context, req *obsgrpc.GetStudioModeEnabledRequest) (*obsgrpc.GetStudioModeEnabledResponse, error) {
	return p.OBSClient.GetStudioModeEnabled(ctx, req)
}
func (p *Proxy) SetStudioModeEnabled(ctx context.Context, req *obsgrpc.SetStudioModeEnabledRequest) (_ret *obsgrpc.SetStudioModeEnabledResponse, _err error) {
	logger.Debugf(ctx, "SetStudioModeEnabled")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/SetStudioModeEnabled: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &ui.SetStudioModeEnabledParams{}
	if req != nil {
		params = &ui.SetStudioModeEnabledParams{
			StudioModeEnabled: ptr(req.StudioModeEnabled),
		}
	}
	resp, err := client.Ui.SetStudioModeEnabled(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.SetStudioModeEnabledResponse{}
	return result, nil
}
func (p *ProxyAsClient) SetStudioModeEnabled(ctx context.Context, req *obsgrpc.SetStudioModeEnabledRequest, opts ...grpc.CallOption) (*obsgrpc.SetStudioModeEnabledResponse, error) {
	return (*Proxy)(p).SetStudioModeEnabled(ctx, req)
}
func (p *ClientAsServer) SetStudioModeEnabled(ctx context.Context, req *obsgrpc.SetStudioModeEnabledRequest) (*obsgrpc.SetStudioModeEnabledResponse, error) {
	return p.OBSClient.SetStudioModeEnabled(ctx, req)
}
func (p *Proxy) OpenInputPropertiesDialog(ctx context.Context, req *obsgrpc.OpenInputPropertiesDialogRequest) (_ret *obsgrpc.OpenInputPropertiesDialogResponse, _err error) {
	logger.Debugf(ctx, "OpenInputPropertiesDialog")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/OpenInputPropertiesDialog: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &ui.OpenInputPropertiesDialogParams{}
	if req != nil {
		params = &ui.OpenInputPropertiesDialogParams{
			InputName: req.InputName,
			InputUuid: req.InputUUID,
		}
	}
	resp, err := client.Ui.OpenInputPropertiesDialog(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.OpenInputPropertiesDialogResponse{}
	return result, nil
}
func (p *ProxyAsClient) OpenInputPropertiesDialog(ctx context.Context, req *obsgrpc.OpenInputPropertiesDialogRequest, opts ...grpc.CallOption) (*obsgrpc.OpenInputPropertiesDialogResponse, error) {
	return (*Proxy)(p).OpenInputPropertiesDialog(ctx, req)
}
func (p *ClientAsServer) OpenInputPropertiesDialog(ctx context.Context, req *obsgrpc.OpenInputPropertiesDialogRequest) (*obsgrpc.OpenInputPropertiesDialogResponse, error) {
	return p.OBSClient.OpenInputPropertiesDialog(ctx, req)
}
func (p *Proxy) OpenInputFiltersDialog(ctx context.Context, req *obsgrpc.OpenInputFiltersDialogRequest) (_ret *obsgrpc.OpenInputFiltersDialogResponse, _err error) {
	logger.Debugf(ctx, "OpenInputFiltersDialog")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/OpenInputFiltersDialog: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &ui.OpenInputFiltersDialogParams{}
	if req != nil {
		params = &ui.OpenInputFiltersDialogParams{
			InputName: req.InputName,
			InputUuid: req.InputUUID,
		}
	}
	resp, err := client.Ui.OpenInputFiltersDialog(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.OpenInputFiltersDialogResponse{}
	return result, nil
}
func (p *ProxyAsClient) OpenInputFiltersDialog(ctx context.Context, req *obsgrpc.OpenInputFiltersDialogRequest, opts ...grpc.CallOption) (*obsgrpc.OpenInputFiltersDialogResponse, error) {
	return (*Proxy)(p).OpenInputFiltersDialog(ctx, req)
}
func (p *ClientAsServer) OpenInputFiltersDialog(ctx context.Context, req *obsgrpc.OpenInputFiltersDialogRequest) (*obsgrpc.OpenInputFiltersDialogResponse, error) {
	return p.OBSClient.OpenInputFiltersDialog(ctx, req)
}
func (p *Proxy) OpenInputInteractDialog(ctx context.Context, req *obsgrpc.OpenInputInteractDialogRequest) (_ret *obsgrpc.OpenInputInteractDialogResponse, _err error) {
	logger.Debugf(ctx, "OpenInputInteractDialog")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/OpenInputInteractDialog: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &ui.OpenInputInteractDialogParams{}
	if req != nil {
		params = &ui.OpenInputInteractDialogParams{
			InputName: req.InputName,
			InputUuid: req.InputUUID,
		}
	}
	resp, err := client.Ui.OpenInputInteractDialog(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.OpenInputInteractDialogResponse{}
	return result, nil
}
func (p *ProxyAsClient) OpenInputInteractDialog(ctx context.Context, req *obsgrpc.OpenInputInteractDialogRequest, opts ...grpc.CallOption) (*obsgrpc.OpenInputInteractDialogResponse, error) {
	return (*Proxy)(p).OpenInputInteractDialog(ctx, req)
}
func (p *ClientAsServer) OpenInputInteractDialog(ctx context.Context, req *obsgrpc.OpenInputInteractDialogRequest) (*obsgrpc.OpenInputInteractDialogResponse, error) {
	return p.OBSClient.OpenInputInteractDialog(ctx, req)
}
func (p *Proxy) GetMonitorList(ctx context.Context, req *obsgrpc.GetMonitorListRequest) (_ret *obsgrpc.GetMonitorListResponse, _err error) {
	logger.Debugf(ctx, "GetMonitorList")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/GetMonitorList: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &ui.GetMonitorListParams{}
	if req != nil {
		params = &ui.GetMonitorListParams{}
	}
	resp, err := client.Ui.GetMonitorList(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.GetMonitorListResponse{
		Monitors: toAbstractObjects[*typedefs.Monitor](resp.Monitors),
	}
	return result, nil
}
func (p *ProxyAsClient) GetMonitorList(ctx context.Context, req *obsgrpc.GetMonitorListRequest, opts ...grpc.CallOption) (*obsgrpc.GetMonitorListResponse, error) {
	return (*Proxy)(p).GetMonitorList(ctx, req)
}
func (p *ClientAsServer) GetMonitorList(ctx context.Context, req *obsgrpc.GetMonitorListRequest) (*obsgrpc.GetMonitorListResponse, error) {
	return p.OBSClient.GetMonitorList(ctx, req)
}
func (p *Proxy) OpenVideoMixProjector(ctx context.Context, req *obsgrpc.OpenVideoMixProjectorRequest) (_ret *obsgrpc.OpenVideoMixProjectorResponse, _err error) {
	logger.Debugf(ctx, "OpenVideoMixProjector")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/OpenVideoMixProjector: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &ui.OpenVideoMixProjectorParams{}
	if req != nil {
		params = &ui.OpenVideoMixProjectorParams{
			VideoMixType:      ptr((string)(req.VideoMixType)),
			MonitorIndex:      ptrInt64ToInt(req.MonitorIndex),
			ProjectorGeometry: ptr((string)(req.ProjectorGeometry)),
		}
	}
	resp, err := client.Ui.OpenVideoMixProjector(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.OpenVideoMixProjectorResponse{}
	return result, nil
}
func (p *ProxyAsClient) OpenVideoMixProjector(ctx context.Context, req *obsgrpc.OpenVideoMixProjectorRequest, opts ...grpc.CallOption) (*obsgrpc.OpenVideoMixProjectorResponse, error) {
	return (*Proxy)(p).OpenVideoMixProjector(ctx, req)
}
func (p *ClientAsServer) OpenVideoMixProjector(ctx context.Context, req *obsgrpc.OpenVideoMixProjectorRequest) (*obsgrpc.OpenVideoMixProjectorResponse, error) {
	return p.OBSClient.OpenVideoMixProjector(ctx, req)
}
func (p *Proxy) OpenSourceProjector(ctx context.Context, req *obsgrpc.OpenSourceProjectorRequest) (_ret *obsgrpc.OpenSourceProjectorResponse, _err error) {
	logger.Debugf(ctx, "OpenSourceProjector")
	defer func() {
		r := recover()
		if r != nil {
			_err = fmt.Errorf("got panic: %v\n\n%s", r, debug.Stack())
		}
		logger.Debugf(ctx, "/OpenSourceProjector: %v", _err)
	}()
	client, onFinish, err := p.GetClient()
	if onFinish != nil {
		defer onFinish()
	}
	if err != nil {
		return nil, fmt.Errorf("unable to get a client: %w", err)
	}
	params := &ui.OpenSourceProjectorParams{}
	if req != nil {
		params = &ui.OpenSourceProjectorParams{
			SourceName:        req.SourceName,
			SourceUuid:        req.SourceUUID,
			MonitorIndex:      ptrInt64ToInt(req.MonitorIndex),
			ProjectorGeometry: ptr((string)(req.ProjectorGeometry)),
		}
	}
	resp, err := client.Ui.OpenSourceProjector(params)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, fmt.Errorf("internal error: resp is nil")
	}
	result := &obsgrpc.OpenSourceProjectorResponse{}
	return result, nil
}
func (p *ProxyAsClient) OpenSourceProjector(ctx context.Context, req *obsgrpc.OpenSourceProjectorRequest, opts ...grpc.CallOption) (*obsgrpc.OpenSourceProjectorResponse, error) {
	return (*Proxy)(p).OpenSourceProjector(ctx, req)
}
func (p *ClientAsServer) OpenSourceProjector(ctx context.Context, req *obsgrpc.OpenSourceProjectorRequest) (*obsgrpc.OpenSourceProjectorResponse, error) {
	return p.OBSClient.OpenSourceProjector(ctx, req)
}
